# Vulnerability Discovery, Exploit Development, and Binary Patching

> Companion to the [deep research report](../deep-research-report.md). This document provides deep technical coverage of taint analysis, automatic exploit generation, ROP chain construction, binary patching, vulnerability pattern detection on binaries, and PoC generation workflows -- with a focus on Ghidra integration opportunities throughout.
>
> Verification note (as of 2026-02-19): exploit-generation success claims, CVE references, and tool maintenance status should be revalidated before operational security decisions.

---

## Table of Contents

1. [Taint Analysis Frameworks](#1-taint-analysis-frameworks)
2. [Automatic Exploit Generation (AEG)](#2-automatic-exploit-generation-aeg)
3. [ROP Chain Generation](#3-rop-chain-generation)
4. [Binary Patching Techniques](#4-binary-patching-techniques)
5. [Vulnerability Pattern Detection on Binaries](#5-vulnerability-pattern-detection-on-binaries)
6. [Proof-of-Concept Generation Workflows](#6-proof-of-concept-generation-workflows)
7. [Ghidra Integration Opportunities](#7-ghidra-integration-opportunities)
8. [Key Takeaways for Ghidra Integration](#8-key-takeaways-for-ghidra-integration)

---

## 1. Taint Analysis Frameworks

Taint analysis tracks how data originating from untrusted sources (taint sources) propagates through a program to security-sensitive operations (taint sinks). It is foundational for vulnerability discovery: if user-controlled data reaches a dangerous function without sanitization, a vulnerability likely exists.

### 1.1 Forward vs. Backward Taint

| Direction | Description | Primary Use Case |
|-----------|-------------|------------------|
| **Forward taint** | Labels input data and propagates labels through execution, tracking where input *can reach*. | Attack surface mapping: "Which sinks can attacker-controlled data reach?" |
| **Backward taint** | Starts from a sink (e.g., `memcpy` size argument) and traces backwards to determine which inputs influence it. | Targeted vuln confirmation: "Can this dangerous sink be influenced by external input?" |

Forward taint is more common in dynamic implementations (instrument every instruction, propagate labels forward). Backward taint is more natural in static/symbolic settings where dataflow is computed over a whole-program representation.

### 1.2 Taint Analysis Tool Comparison

| Tool / Framework | Basis | Granularity | Architectures | Forward / Backward | Key Characteristics |
|------------------|-------|-------------|---------------|-------------------|---------------------|
| **PANDA taint2** | QEMU whole-system emulation | Byte-level with label sets | x86, x64, ARM, MIPS, PPC (any QEMU target) | Forward | Full-system taint (kernel + userland); LLVM-based taint propagation inlined into translated code (~10x faster than PANDA taint1); supports label-set queries and callbacks for custom taint policies |
| **PANDA ida_taint2** | PANDA taint2 + IDA/Ghidra export | Function/instruction level | Same as PANDA | Forward | Post-processes taint2 logs to color-code tainted instructions in IDA Pro or Ghidra; bridges dynamic taint results into static RE tools |
| **Triton** | Pin-based DBA (also standalone emulation) | Byte/bit-level | x86, x86-64, AArch64 | Forward | Combines taint engine + symbolic execution engine + SMT solver (Z3) in a single library; Python bindings; can perform taint-guided symbolic execution; used for deobfuscation of VM protectors |
| **TritonDSE** | Built on Triton | Same as Triton | Same as Triton | Forward | Python framework adding DSE (dynamic symbolic execution) orchestration on top of Triton's engines; provides exploration strategies, callbacks, and coverage-guided seed scheduling |
| **angr** (SimProcedure + taint) | VEX IR lifting + symbolic execution | Symbolic (bit-level via constraints) | x86, x64, ARM, AArch64, MIPS, PPC, etc. | Both | Taint is implicit in symbolic execution: if a memory location contains a symbolic variable derived from input, it is "tainted." Forward tracking via concolic execution; backward via dependency analysis on symbolic constraints. The `reaching_definitions` analysis provides explicit data-flow (def-use) tracking |
| **DataFlowSanitizer (DFSan)** | LLVM compiler instrumentation | Byte-level labels (up to 2^16 labels) | Any LLVM target (requires source) | Forward | Compile-time instrumentation; fastest taint tracking for source-available targets; used by fuzzers (e.g., Angora uses DFSan for taint-guided mutation); DTaint extends DFSan with inference-based taint |
| **libdft / libdft64** | Pin-based (Intel Pin DBI) | Byte-level | x86, x86-64 | Forward | Classic binary-level dynamic taint analysis; foundation for many research systems; performance overhead ~2-5x |

### 1.3 Binary-Level Taint Propagation Techniques

**Instruction-level propagation rules.** Every machine instruction is modeled as a transfer function for taint labels. For example, `add rax, rbx` propagates the union of taint labels from both operands to the destination. This must handle:
- **Arithmetic/logic ops**: Union of input labels to output.
- **Memory ops**: `load` inherits labels from both the address (if tainted address = potential arbitrary read) and the loaded value. `store` propagates value labels to memory, and tainted addresses flag potential arbitrary writes.
- **Control flow**: Taint on branch conditions implies *implicit flow* (data-dependent control flow). Most practical tools track only *explicit* (data) flow to avoid taint explosion.

**Intermediate representation (IR) based propagation.** Tools like PANDA (LLVM IR), angr (VEX IR), and Triton (its own AST) lift binary instructions to an IR first, then define taint propagation on the simpler IR operations. This decouples architecture-specific details from the taint logic, enabling multi-architecture support.

**Over-tainting vs. under-tainting.** A fundamental tradeoff: conservative propagation (e.g., tainting through all arithmetic) leads to over-tainting (false positives at sinks), while aggressive pruning (e.g., clearing taint on constant-derived values) risks under-tainting (missed vulnerabilities). Practical systems often provide tunable policies.

### 1.4 PANDA taint2 Deep Dive

PANDA (Platform for Architecture-Neutral Dynamic Analysis) records and replays full-system executions under QEMU. The `taint2` plugin is its second-generation taint analysis engine:

- **Architecture**: PANDA translates guest code to TCG (QEMU's intermediate), then to LLVM IR using the S2E infrastructure. Taint propagation rules are defined on LLVM IR operations, giving architecture neutrality automatically.
- **Label management**: Each taint label is a 32-bit identifier. Labels form sets at each byte. The system supports millions of labels (e.g., labeling every byte of a network packet individually).
- **Performance**: taint2 inlines taint operations into LLVM JIT-compiled code rather than buffering and post-processing, achieving roughly 10x speedup over taint1.
- **Callbacks**: `on_taint_change` callback fires when a memory/register byte gains or loses a taint label. `taint2_query` checks if a location is tainted. `taint2_label_addr` / `taint2_label_reg` apply labels.
- **Downstream plugins**: `ida_taint2` exports taint results as instruction-level coloring for IDA or Ghidra. `tainted_branch` logs control-flow decisions influenced by tainted data. `tainted_instr` counts tainted instructions.

### 1.5 Triton Architecture

Triton (https://github.com/JonathanSalwan/Triton) provides three tightly coupled engines:

1. **Taint engine**: Byte/register-level taint propagation with configurable policies (spread, assignment semantics). Taint state is queried per register or memory address.
2. **Symbolic execution engine**: Builds AST representations of instruction semantics. Every tainted byte has an associated symbolic expression. The AST can be simplified and converted to SMT-LIB for solving.
3. **AST/SMT layer**: Z3 is the default solver. Triton's AST supports simplification passes (constant folding, algebraic simplification, MBA deobfuscation).

Triton was originally Pin-based (requiring Intel Pin for instrumentation) but now also supports standalone emulation mode, where the user feeds instructions manually. TritonDSE (by Quarkslab) wraps Triton with a DSE orchestration layer providing exploration strategies, coverage tracking, and seed management -- making it practical for end-to-end vulnerability discovery on binaries.

---

## 2. Automatic Exploit Generation (AEG)

AEG systems attempt to automatically transform a vulnerable binary into a working exploit, typically by: (1) finding a crashing input (via fuzzing or symbolic execution), (2) analyzing the crash to determine exploitability, (3) crafting an exploit payload that achieves a desired effect (e.g., shell execution).

### 2.1 Historical Context: DARPA CGC and the AEG Landscape

The 2016 DARPA Cyber Grand Challenge (CGC) was the watershed moment for AEG. Seven autonomous Cyber Reasoning Systems (CRSs) competed to find, exploit, and patch vulnerabilities in real time on the custom DECREE OS:

| System | Team | Placement | Key Techniques |
|--------|------|-----------|----------------|
| **Mayhem** | ForAllSecure (CMU) | 1st | Hybrid symbolic execution + fuzzing; index-based memory model; binary instrumentation via Pin; concolic execution with selective symbolic memory |
| **Xandra** | TECHx (GrammaTech) | 2nd | Intermediate representation (CodeSurfer IR) analysis; symbolic execution; binary rewriting for patching |
| **Mechanical Phish** | Shellphish (UCSB) | 3rd | angr-based symbolic execution; Driller (fuzzing + concolic); Rex (crash → exploit); Patcherex (automated patching); angrop (ROP chain generation) |

**Post-CGC evolution**: ForAllSecure commercialized Mayhem as a SaaS platform for automated software testing. The Shellphish components (angr, Rex, Driller, Patcherex, angrop) became the most widely used open-source AEG ecosystem.

### 2.2 angr's Rex Module

Rex (https://github.com/angr/rex) is Shellphish's automated exploitation engine. It takes a crashing input and attempts to produce a working exploit:

**Pipeline:**
1. **Crash reproduction**: Load the binary in angr, drive concolic execution along the crash path using the crashing input as a concrete trace guide.
2. **Crash analysis**: At the crash point, inspect the symbolic state:
   - Is the program counter (PC) symbolic? → Potential control-flow hijack.
   - Is a write target symbolic? → Potential arbitrary write.
   - Is a read target symbolic? → Potential information leak.
   - Classify as: `ip_overwrite`, `write_what_where`, `partial_ip_overwrite`, `null_dereference`, etc.
3. **Exploit strategy selection**: Based on crash type:
   - **Type 1** (register set): Constrain symbolic PC to point to controlled data, place shellcode.
   - **Type 2** (memory leak): Constrain execution to leak the flag page.
   - For Linux: attempt ret2libc, ret2dlresolve, ROP chain (via angrop).
4. **Constraint solving**: Use angr's constraint solver (Claripy/Z3) to produce a concrete input that satisfies all exploit constraints.
5. **Payload assembly**: Generate the final exploit input using pwntools.

**Supported exploit types** (from `rex/exploit/exploit.py`):
- Register-setting exploits (control all registers via symbolic constraints)
- Memory leaking exploits (constrain execution to leak from arbitrary addresses)
- ROP-based exploits (chain gadgets via angrop when no executable data region exists)
- ret2dlresolve chains for 64-bit binaries

**Limitations:**
- Best on small-to-medium binaries with clear crash paths
- Struggles with complex heap exploitation, multi-stage vulnerabilities
- Path explosion remains a bottleneck for large binaries
- Originally designed for DECREE (CGC OS); Linux support is present but less mature

### 2.3 Zeratool

Zeratool (https://github.com/ChrisTheCoolHut/Zeratool) is an AEG tool specifically targeting CTF-style problems:

- Uses angr for concolic analysis: hooks `printf` and looks for unconstrained paths (symbolic PC)
- Automatically weaponizes program states for RCE via pwntools
- Supports remote libc leaking (leaks GOT entries via `puts`/`printf` to calculate offsets)
- Generates ret2dlresolve chains for 64-bit, smart ROP chains for `execve`/`system`
- Available as a Python library (`zeratool_lib` fork) for programmatic use
- Practical for simple stack-based buffer overflows; limited for heap or format-string exploitation

### 2.4 ForAllSecure Mayhem

Mayhem combines two complementary approaches:

1. **Concolic execution engine (CES)**: Performs online symbolic execution alongside concrete execution. Uses an index-based memory model that models memory as a flat array with symbolic indices -- more scalable than fully symbolic memory.
2. **Symbolic-assisted fuzzing (SAF)**: Uses lightweight symbolic reasoning to solve "hard" branch constraints that pure fuzzing cannot reach, then feeds solutions back to the fuzzer.

The system found ~14,000 unique vulnerabilities in the Debian distribution in under a week (2014 evaluation). The commercial Mayhem platform now provides continuous automated testing for binary and source-level targets.

### 2.5 Current State of AEG (2024-2025)

**DARPA AIxCC (AI Cyber Challenge, 2024-2025)**: The successor to CGC, AIxCC focuses on using AI/LLMs for vulnerability discovery and patching in real-world open-source software. In the 2024 semifinals at DEF CON 32:
- ~40 Cyber Reasoning Systems competed
- Systems discovered 22 unique synthetic vulnerabilities in Jenkins, Linux kernel, Nginx, SQLite3, and Apache Tika
- 15 of those were automatically patched
- One real-world SQLite3 bug was found and responsibly disclosed
- LLMs are used for seed generation for fuzzing, vulnerability pattern recognition, and patch generation

**Advances and remaining limitations:**

| Aspect | Progress | Remaining Challenges |
|--------|----------|---------------------|
| Stack-based overflows | Largely solvable by Rex/Zeratool for simple cases | Complex layouts, canaries, ASLR interaction |
| Heap exploitation | Limited automated support (some research prototypes) | Heap layout manipulation, grooming, allocator-specific chains |
| Format string | Some tools detect; few auto-exploit | Multi-write chains, RELRO bypass |
| Use-after-free | Detectable via sanitizers + fuzzing | Triggering order, heap feng shui for exploitation |
| Logic bugs | LLM-based detection emerging (AIxCC) | Semantic understanding required; no reliable automation |
| Multi-step / chained | Research-stage only | State explosion, environment modeling |

### 2.6 Key AEG Papers and Resources

- Avgerinos et al., "AEG: Automatic Exploit Generation" (CCS 2011) -- the foundational paper
- Cha et al., "Unleashing Mayhem on Binary Code" (IEEE S&P 2012) -- Mayhem system paper
- Shoshitaishvili et al., "SOK: (State of) The Art of War" (IEEE S&P 2016) -- angr and the CGC ecosystem
- Huang et al., "BofAEG: Automated Stack Buffer Overflow Vulnerability Detection and Exploit Generation" (2022) -- combining symbolic execution and dynamic analysis
- DARPA AIxCC SoK paper (arXiv:2602.07666, 2025) -- comprehensive analysis of AIxCC competition design and CRS architectures

---

## 3. ROP Chain Generation

Return-Oriented Programming (ROP) chains code-reuse attacks by chaining together short instruction sequences ("gadgets") ending in `ret` to perform arbitrary computation despite W^X (non-executable stack) protections.

### 3.1 ROP Chain Generation Tool Comparison

| Tool | Language | Arch Support | Chain Generation | Gadget Finding | Key Differentiator |
|------|----------|-------------|------------------|----------------|-------------------|
| **ROPgadget** | Python | x86, x64, ARM, ARM64, PPC, SPARC, MIPS, RISC-V | Basic (ropchain generation for execve) | Comprehensive; supports ELF, PE, Mach-O | Broadest architecture/format support; de facto standard for gadget search |
| **Ropper** | Python (angr framework for disassembly) | x86, x64, ARM, ARM64, MIPS, PPC | Interactive search, bad-char filtering, semantic search | Finds significantly more gadgets than angrop per 2024 study | Colored output, interactive CLI, semantic gadget search, JOP/SYS gadget support |
| **angrop** | Python (angr) | x86, x64 (primary) | Automated ROP chain compilation; integrates with angr symbolic state | Fewer gadgets than Ropper but semantically verified | Tight integration with angr's symbolic execution; chains are constraint-checked; used by Rex for AEG |
| **ROPium** | Python + C++ | x86, x64, ARM | Semantic chain building (specify high-level intent like "rax = 0x41414141") | Uses ROPgadget for discovery | Semantic API: specify register values, memory writes, function calls; finds chains automatically |
| **ropbot** | Python (angr + networkx) | x86, x64 | O(n) graph-based chain synthesis via ROPBlocks | Position-dependent caching; fast | Novel ROPBlock abstraction guarantees chainability; outperforms all prior tools in benchmarks; NDSS 2026 paper |
| **ropr** | Rust | x86, x64 | Gadget finding only | Blazing fast multi-threaded search | Pure gadget finder optimized for speed; no chain generation |
| **rp++** | C++ | x86, x64, ARM, ARM64 | Gadget finding only | Fast C++ implementation | ELF/PE/Mach-O support; widely used for quick gadget enumeration |

### 3.2 How Automated ROP Compilation Works

Modern ROP chain generators work by:

1. **Gadget discovery**: Scan the binary's executable sections for byte sequences ending in `ret` (or `jmp reg` for JOP). Disassemble backwards from each `ret` to find valid instruction sequences.
2. **Semantic analysis**: Symbolically execute each gadget to determine its effect (e.g., "pops stack into rdi", "writes rax to [rbx]", "adds rax and rcx"). Tools like angrop and ropbot use angr's symbolic execution for this.
3. **Gadget classification**: Categorize gadgets by effect: register setters, memory readers/writers, arithmetic operations, stack pivots, syscall invocations.
4. **Chain compilation**: Given a goal (e.g., "call execve('/bin/sh', NULL, NULL)"), decompose into sub-goals (set rdi, rsi, rdx, rax; invoke syscall) and find a sequence of gadgets that achieves each sub-goal while maintaining a consistent stack layout.
5. **Constraint solving**: Verify that gadget side effects don't clobber previously-set values. ropbot's ROPBlock abstraction solves this by grouping gadgets into blocks guaranteed not to interfere.

### 3.3 ropbot: The State of the Art (NDSS 2026)

ropbot introduces key innovations:

- **ROPBlocks**: Groups of gadgets where any gadget in the group can precede any other without clobbering useful state. This converts the chain synthesis problem from exponential backtracking to linear graph search (O(n)).
- **Position-dependent caching**: Position-independent gadgets (e.g., from shared libraries) are analyzed once and cached, dramatically speeding up repeated analysis.
- **Benchmark results**: ropbot outperforms ROPgadget, Ropper, angrop, and ROPium on the register-setting chain generation task across standard benchmarks.

### 3.4 JOP/COP Variants

| Variant | Mechanism | Dispatcher | Key Challenge |
|---------|-----------|------------|---------------|
| **JOP** (Jump-Oriented Programming) | Gadgets end in `jmp reg` | Dispatcher gadget loads next target from a "dispatch table" | Finding a suitable dispatcher gadget; table layout |
| **COP** (Call-Oriented Programming) | Gadgets end in `call reg/mem` | Similar dispatch mechanism via call targets | Stack frame management across calls |
| **MAJORCA** | Multi-architecture JOP+ROP assembler | Handles both JOP and ROP chains across architectures | Academic research (arxiv:2111.05781); demonstrates cross-arch generality |
| **Sigreturn-Oriented Programming (SROP)** | Uses `sigreturn` syscall to set all registers from a crafted signal frame | Single gadget: `mov rax, 15; syscall` | Very powerful when available; only needs one gadget |

### 3.5 Modern Mitigations and Their Impact

| Mitigation | Mechanism | Impact on ROP | Status (2024-2025) |
|------------|-----------|---------------|---------------------|
| **Intel CET (Shadow Stack)** | Hardware-maintained shadow stack stores return addresses; `ret` validates against shadow copy | Breaks classic ROP: `ret` to a non-call-site address triggers a #CP exception | Deployed in Windows 11 (user+kernel mode); Linux support in mainline kernel; requires CPU support (Intel 11th+ gen, AMD Zen 3+) |
| **Intel CET (IBT)** | Indirect Branch Tracking: indirect jumps/calls must target `ENDBR64` instructions | Breaks JOP/COP: limits valid indirect branch targets | Same deployment as shadow stack; coarser than shadow stack |
| **ARM PAC** (Pointer Authentication) | Cryptographic signature (PAC) stored in unused upper bits of 64-bit pointers; validated before use | Breaks ROP: return addresses are signed with a per-process key; forged addresses fail validation | Deployed in Apple M1+ (iOS/macOS); ARMv8.3+ required; adopted by Android/Linux |
| **ARM BTI** (Branch Target Identification) | Landing-pad instructions (`bti`) required at valid indirect branch targets | Limits JOP/COP gadget availability | ARMv8.5+; complementary to PAC |
| **ASLR** | Randomizes code/data segment addresses | Requires info leak to locate gadgets; does not prevent ROP if leak exists | Universal; 32-bit ASLR is weak (brute-forceable) |
| **CFI** (Control-Flow Integrity, various implementations) | Limits valid targets for indirect branches based on program CFG | Reduces gadget reachability; COOP attacks can bypass coarse-grained CFI | LLVM CFI widely available; varying granularity |

**Post-mitigation ROP landscape**: With CET+PAC deployed on modern hardware, classic ROP chains are increasingly blocked. Researchers have demonstrated bypasses (e.g., Counterfeit Object-Oriented Programming (COOP) against coarse CFI; PAC forgery under specific conditions), but the bar for exploitation has been raised significantly. Automated ROP tools must now account for: (1) which mitigations are active, (2) whether an info leak is available, and (3) whether CET/PAC can be bypassed in the target environment.

---

## 4. Binary Patching Techniques

Binary patching modifies a compiled binary without access to source code. Use cases include: vulnerability remediation, instrumentation, hardening, CTF defense, and software customization.

### 4.1 Patching Approach Comparison

| Tool / Technique | Approach | Arch Support | Source Needed? | Key Strengths | Key Limitations |
|------------------|----------|-------------|----------------|---------------|-----------------|
| **Ghidra Patch Instruction** | In-place assembly modification via GUI | All Ghidra-supported architectures | No | Interactive; immediate preview; export patched binary (ELF/PE since Ghidra 10.0) | Manual; limited to instruction-sized changes unless adding NOPs or trampolines |
| **Patcherex** (original, angr) | Automated binary patching with techniques: InsertCodePatch, AddCodePatch, AddRODataPatch, etc. | x86, x64, ARM, MIPS (CGC DECREE, Linux ELF) | No | Shellphish's CGC patching engine; techniques include detour-based patching, data insertion, and full binary reassembly | Older codebase; CGC-focused; less maintained |
| **Patcherex2** (purseclab) | Rewrite of Patcherex with modern architecture; modular backends (ELF, PE, Mach-O) | x86, x64, ARM, AArch64, MIPS, PPC | No | Clean API; pip-installable; supports multiple binary formats; extensible target/backend system | Newer project; still maturing |
| **e9patch** | Static binary rewriting via instruction punning/padding/eviction | x86-64 Linux ELF | No | No CFG recovery needed; handles binaries >100MB; drop-in replacement output; multiple modes (default, CFR, 100% coverage) | x86-64 Linux only; trampoline overhead for some patches |
| **LIEF** | Library for parsing, modifying, and rebuilding binary formats | Cross-platform (ELF, PE, Mach-O) | No | Programmatic binary format manipulation; Python/C++ API; can modify sections, segments, imports, exports | Lower-level than patching tools; no assembly/disassembly built-in |
| **Binary Ninja patching** | GUI patching with preview; "Patch → Write to file" | All BN-supported architectures | No | Smooth UX; immediate assembly preview; write-back to file | Commercial tool |
| **fidget** (angr) | Inline patches to rearrange stack frames | x86, x64 | No | Automatically adjusts stack layouts for hardening | Specialized; limited scope |
| **ARMPatch** | ARM-focused binary patching framework for IoT devices | ARM | No | Specialized for embedded/IoT; handles ARM-specific patching challenges | ARM-only |

### 4.2 Patching Strategy Details

#### Inline Patching
- Modify instructions in-place without changing the binary's layout
- Limited to changes that fit within the same instruction byte count
- For smaller replacements, pad with NOPs
- For larger changes, replace original instructions with a `jmp` to a trampoline (see detour-based)
- Ghidra's "Patch Instruction" uses this approach: right-click an instruction, modify the assembly, and the bytes are updated in-place

#### Detour-Based Patching
- Insert a `jmp` (5 bytes on x86) at the patch site, redirecting to new code in an added section
- New code performs the desired operation, then jumps back to continue original execution
- Patcherex's `InsertCodePatch` uses this pattern
- e9patch uses a sophisticated version: instruction punning (reusing bytes that happen to encode valid jumps), padding (using alignment bytes), and eviction (moving instructions to make room) -- all without needing control flow recovery

#### Binary Reassembly
- Fully disassemble the binary, modify the IR/assembly, and reassemble
- Most flexible but most error-prone (requires correct disassembly and relocation)
- Tools: Retrowrite (position-independent code only), Ramblr (angr-based), ddisasm (GrammaTech)
- Patcherex supports a reassembly backend for maximum flexibility

#### Section/Segment Manipulation
- Add new sections (`.patch`, `.injected`) containing patch code
- Modify segment permissions, add new segments
- LIEF provides programmatic APIs for this across ELF/PE/Mach-O
- e9patch adds trampolines in new sections automatically

### 4.3 e9patch Deep Dive

e9patch (https://github.com/GJDuck/e9patch) achieves static binary rewriting *without control flow recovery* (PLDI 2020 paper):

**Core insight**: Instead of understanding the program's control flow to safely move instructions, e9patch modifies instructions *in place* using three techniques:

1. **Instruction punning**: Find existing byte sequences that happen to encode a valid `jmp` to the trampoline. The original bytes are preserved but reinterpreted.
2. **Padding exploitation**: Use existing padding bytes (alignment NOPs, inter-function padding) to place short jumps.
3. **Instruction eviction**: Move a small number of instructions to a trampoline when punning and padding are insufficient. Only the evicted instructions need relocation.

**e9tool** is the companion instrumentation tool that generates patches for e9patch. It provides a DSL for specifying which instructions to instrument and what code to inject. Modes:
- **Default**: Classic rewriting without CFG
- **CFR**: Uses control flow recovery for higher-quality rewrites
- **100%**: Full coverage mode that guarantees every instruction can be patched

**Performance**: e9patch typically adds only ~2 extra instructions (jumps to/from trampoline) per patch site, making it among the lowest-overhead binary rewriting tools.

### 4.4 Patcherex2 Architecture

Patcherex2 (https://github.com/purseclab/Patcherex2) provides a clean, extensible architecture:

```
Patcherex2 Architecture:
  Target (binary) → Analysis Backend (angr, Ghidra, etc.)
                   → Patch Specification (InsertCode, ModifyCode, AddData, etc.)
                   → Rewriting Backend (ELF, PE, Mach-O specific)
                   → Patched Binary Output
```

Patch types supported:
- `InsertCodePatch`: Insert code at an address (detour-based)
- `ModifyCodePatch`: Replace instructions at an address
- `ModifyDataPatch`: Modify data bytes
- `AddCodePatch`: Add new code accessible via label
- `AddDataPatch`: Add new data accessible via label
- `ModifyFunctionPatch`: Replace an entire function with C code (compiled with a cross-compiler)

### 4.5 Ghidra Patching Workflow

Ghidra provides multiple paths for binary patching:

1. **GUI "Patch Instruction"**: Right-click any instruction in the Listing view → Patch Instruction → type new assembly → Ghidra assembles in-place
2. **Byte patching**: In the Byte Viewer, directly edit hex bytes
3. **Script-based patching**: Use `Assemblers` API in Ghidra scripts to programmatically patch:
   ```java
   Assembler asm = Assemblers.getAssembler(currentProgram);
   asm.assemble(addr("0x401000"), "nop");
   ```
4. **Export patched binary**: File → Export Program → choose ELF/PE format (available since Ghidra 10.0); or use community scripts like `ghidra_SavePatch` to write modifications back to the original file
5. **Headless patching**: Run patching scripts via `analyzeHeadless` for batch operations

**ghidra_SavePatch** (https://github.com/schlafwandler/ghidra_SavePatch): A Ghidra script that writes small modifications made in the GUI back to the analyzed file, without requiring export.

---

## 5. Vulnerability Pattern Detection on Binaries

Traditional vulnerability scanners (CodeQL, Semgrep, Joern) operate on source code. A growing set of techniques and tools now apply these approaches to decompiled output or directly to binary representations.

### 5.1 Tool Comparison for Binary Vulnerability Detection

| Tool / Approach | Input | Analysis Method | Vulnerability Types | Strengths | Limitations |
|-----------------|-------|-----------------|--------------------|-----------|----|
| **BinAbsInspector** (Ghidra plugin) | Binary (via Ghidra P-code) | Abstract interpretation | Buffer overflow, integer overflow, command injection, use-after-free, double-free, null deref, CWE series | Native Ghidra integration; multi-arch (x86, x64, ARMv7, AArch64); headless/GUI/Docker modes | Relies on abstract domain precision; false positive rate varies by checker; limited maintenance recently |
| **Joern + ghidra2cpg** | Binary (via Ghidra → CPG) | Code Property Graph queries (Scala DSL) | Any pattern expressible as graph query: taint paths, dangerous API usage, type confusion | Architecture-neutral (uses Ghidra's P-code); powerful query language; compositional analysis | Requires Joern expertise; CPG generation overhead; decompilation quality affects results |
| **CodeQL on decompiled output** | Decompiled C (from Ghidra/Hex-Rays) | Database-backed dataflow/taint queries (QL language) | Buffer overflows, injection, auth bypass, any QL-expressible pattern | Mature query library (originally for source); deep inter-procedural analysis; used in production at GitHub | Not designed for decompiled code (naming, type artifacts); requires building a CodeQL database from decompiled output; Zetier has demonstrated this workflow |
| **Semgrep on decompiled C** | Decompiled C pseudocode | Pattern matching + taint tracking | Common C vulnerability patterns, dangerous function usage | Fast; easy rule writing; lower barrier than CodeQL; Sekiryu toolkit integrates Semgrep with Ghidra headless | Pattern-based (limited inter-procedural); decompiled code quirks cause false positives/negatives |
| **VulHunt** (Binarly) | Binary (multi-arch IR) | Dataflow analysis + pattern matching + LLM integration | Known vulnerability patterns, unsafe data flows, malicious code | Architecture-agnostic IR; LLM-assisted analysis; type library support for reasoning | Commercial platform; newer |
| **LLM-assisted detection** (various: GhidrAssist, Sekiryu+ChatGPT, custom agents) | Decompiled code / disassembly | LLM reasoning over code snippets | Heuristic: buffer overflows, logic flaws, auth issues | Can reason about semantics that pattern matchers miss; good at summarization | Non-deterministic; hallucination risk; no formal guarantees; context window limits |
| **BSim** (Ghidra built-in) | Binary functions (feature vectors from decompiler) | Cosine similarity of decompiler-derived feature vectors | Vulnerability *search* (not detection): "find functions similar to known-vulnerable function X" | Cross-architecture; cross-compiler; built into Ghidra; scales to large corpora with PostgreSQL/Elastic backend | Finds similar functions, not vulnerabilities directly; requires a reference set of known-vulnerable functions |

### 5.2 BinAbsInspector Deep Dive

BinAbsInspector (https://github.com/KeenSecurityLab/BinAbsInspector) from Tencent KeenLab uses abstract interpretation on Ghidra's P-code:

**Abstract domains:**
- **Local (stack) region**: Models each function's stack frame with abstract values
- **Heap region**: Context-sensitive heap modeling (each allocation site under different calling contexts gets a separate abstract heap object)
- **Global region**: Models global/static data
- **Unique region**: Ghidra P-code temporary variables
- **Register region**: Abstract register state

**Checkers included:**
- `CWE134`: Use of externally-controlled format string
- `CWE190`: Integer overflow or wraparound
- `CWE367`: TOCTOU race condition
- `CWE415`: Double free
- `CWE416`: Use after free
- `CWE426`: Untrusted search path
- `CWE467`: Use of sizeof() on a pointer type
- `CWE476`: NULL pointer dereference
- `CWE676`: Use of potentially dangerous function
- `CWE78`: OS command injection
- `CWE119/CWE125/CWE787`: Buffer overflow family

**Usage modes:**
- **GUI**: Load binary in Ghidra → Window → Script Manager → BinAbsInspector
- **Headless**: `analyzeHeadless /tmp/project project -import binary -postScript BinAbsInspector.java`
- **Docker**: Pre-built container for batch scanning

### 5.3 Joern CPG Analysis on Binaries

Joern (https://github.com/joernio/joern) creates a Code Property Graph (CPG) that unifies:
- **Abstract Syntax Tree (AST)**: Structure of the code
- **Control Flow Graph (CFG)**: Execution paths
- **Data Flow Graph (DFG)**: Data dependencies
- **Program Dependence Graph (PDG)**: Combined control + data dependencies

**ghidra2cpg** (https://github.com/joernio/ghidra2cpg) generates a CPG from binary code:

1. Ghidra disassembles and decompiles the binary
2. P-code operations are translated into CPG nodes and edges
3. The resulting CPG can be queried with Joern's Scala DSL

**Example vulnerability queries:**
```scala
// Find calls to strcpy with non-constant source
cpg.call("strcpy").argument(2).isLiteral.l  // check if source is literal

// Find functions that read from network and call system()
cpg.call("recv").caller.callee.name("system").l

// Taint analysis: track data from read() to memcpy()
cpg.call("read").argument(2).reachableByFlows(cpg.call("memcpy").argument(1)).l
```

**Advantages for binary analysis:**
- Architecture-neutral: Ghidra handles the lifting, Joern handles the querying
- Same query language works for source code and binary analysis
- Compositional: combine multiple analyses (taint + control flow + type) in single queries

### 5.4 CodeQL on Decompiled Output

Zetier (https://zetier.com/codeql-for-binaries/) demonstrated using CodeQL on decompiled binary output:

**Workflow:**
1. Decompile binary with Ghidra/Hex-Rays to produce C pseudocode
2. Create a CodeQL database from the decompiled C (treating it as source)
3. Run CodeQL queries against the database
4. Map findings back to binary addresses

**Challenges:**
- Decompiled code uses synthetic variable names (`local_10h`, `param_1`)
- Type recovery artifacts (incorrect types) can cause false positives/negatives
- CodeQL's built-in C/C++ queries assume idiomatic source code patterns
- Custom queries are needed to handle decompiler-specific patterns

**DecLLM approach**: Using LLMs to improve decompiled output (rename variables, recover types, add comments) before running CodeQL/Semgrep can improve detection accuracy.

### 5.5 BSim for Vulnerability Search

Ghidra's BSim provides a different angle on vulnerability detection -- *similarity search* rather than pattern detection:

**Concept**: If you have a known-vulnerable function (e.g., a specific version of `ssl3_get_key_exchange` with Heartbleed), you can search an entire corpus of binaries for functions that are structurally similar.

**How BSim works:**
1. Ghidra's decompiler generates a normalized representation of each function
2. Feature vectors are extracted from the decompiler output (small pieces of data flow and control flow)
3. Vectors are stored in a database (H2, PostgreSQL, or Elasticsearch)
4. Queries compute cosine similarity between a target function's vector and all stored vectors
5. Matches above a configurable threshold are returned with similarity and confidence scores

**Vulnerability search workflow:**
1. Build a BSim database of known-vulnerable library versions
2. Import target binaries into the database
3. Query: "find all functions in target binaries similar to known-vulnerable functions"
4. Results show matches with similarity scores, enabling triage

**Database backends:**
- **H2**: File-based, good for small-to-medium corpora
- **PostgreSQL**: Server-based, good for large corpora and team access
- **Elasticsearch**: Best for very large-scale similarity search

---

## 6. Proof-of-Concept Generation Workflows

PoC generation combines multiple techniques into an end-to-end pipeline: static analysis identifies potential vulnerabilities, symbolic execution confirms reachability, constraint solving generates inputs, and exploit frameworks package the result.

### 6.1 The Canonical Pipeline: Static RE → Symbolic Execution → Constraint Solving → PoC

```
  ┌──────────────┐     ┌──────────────────┐     ┌─────────────────┐
  │ Static RE     │     │ Symbolic/Concolic │     │ Constraint      │
  │ (Ghidra/IDA)  │────▶│ Execution (angr)  │────▶│ Solving (Z3)    │
  │               │     │                   │     │                 │
  │ - Identify    │     │ - Explore paths   │     │ - Solve for     │
  │   vuln sinks  │     │   to vuln sink    │     │   concrete      │
  │ - Map attack  │     │ - Build symbolic  │     │   input that    │
  │   surface     │     │   constraints     │     │   triggers vuln │
  │ - Extract CFG │     │ - Hook functions  │     │                 │
  └──────────────┘     └──────────────────┘     └────────┬────────┘
                                                          │
                                                          ▼
                                                ┌─────────────────┐
                                                │ PoC Assembly    │
                                                │ (pwntools)      │
                                                │                 │
                                                │ - Format input  │
                                                │ - Add payload   │
                                                │ - Test against  │
                                                │   target        │
                                                └─────────────────┘
```

### 6.2 Step-by-Step Workflow

**Step 1: Static analysis and target identification**
- Load binary in Ghidra; run auto-analysis
- Identify potentially dangerous functions: `strcpy`, `memcpy`, `sprintf`, `system`, `execve`, `free` (double-free patterns)
- Use BinAbsInspector or Joern CPG queries to find candidate vulnerabilities
- Export function addresses, call graph, and decompiled code for the vulnerable path

**Step 2: Symbolic execution setup**
```python
import angr

proj = angr.Project("./vuln_binary", auto_load_libs=False)
state = proj.factory.entry_state(
    stdin=angr.SimFile(name='stdin', content=angr.claripy.BVS('stdin', 1024*8))
)
simgr = proj.factory.simgr(state)

# Explore to the vulnerable function
simgr.explore(find=0x401234)  # address of vulnerable call
```

**Step 3: Constraint building and solving**
```python
if simgr.found:
    found_state = simgr.found[0]
    # Add exploit constraints (e.g., overwrite return address)
    found_state.solver.add(
        found_state.regs.rip == 0xdeadbeef  # desired control target
    )
    # Solve for input
    poc_input = found_state.solver.eval(stdin_content, cast_to=bytes)
```

**Step 4: PoC packaging**
```python
from pwn import *

p = process("./vuln_binary")
p.sendline(poc_input)
p.interactive()
```

### 6.3 The Mayhem/angr Pipeline (Industrial Scale)

ForAllSecure's Mayhem and the angr ecosystem implement this pipeline at industrial scale:

**Mayhem's approach:**
1. **Seed generation**: Fuzzing (AFL-style mutation) produces initial test cases
2. **Crash triage**: Crashes are deduplicated and classified by root cause
3. **Symbolic analysis**: Concolic execution (CES) explores crash paths symbolically
4. **Exploitability assessment**: Classify crash as exploitable (IP control, write-what-where) or benign (null deref, stack guard)
5. **Exploit generation**: For exploitable crashes, synthesize payloads (Rex-style)
6. **Patch generation**: Automatically generate binary patches to remediate (Patcherex-style)

**angr ecosystem pipeline:**
1. **Driller**: Fuzzing (AFL) + concolic execution. AFL handles easy paths; when stuck, angr's symbolic execution solves the hard branch constraints and feeds new inputs back to AFL.
2. **Rex**: Takes Driller's crashes and attempts automatic exploitation (see Section 2.2).
3. **angrop**: Generates ROP chains when needed for the exploit.
4. **Patcherex/Patcherex2**: Generates defensive patches (add bounds checks, replace vulnerable functions, insert canaries).

### 6.4 Taint-Guided PoC Generation

Taint analysis can focus symbolic execution on the relevant subset of the program:

1. **Dynamic taint**: Run the program with a seed input under PANDA/Triton taint tracking
2. **Identify tainted sinks**: Find which dangerous operations receive tainted data
3. **Focused symbolic execution**: Only symbolize the input bytes that actually reach the sink (determined by taint labels), dramatically reducing the constraint complexity
4. **Solve**: Z3/Bitwuzla solves for the specific input bytes that trigger the vulnerability

This "taint-guided concolic" approach is used by systems like Angora (DFSan-based taint + gradient descent solving) and hybrid fuzzers that combine taint information with coverage-guided mutation.

### 6.5 LLM-Assisted PoC Generation (Emerging)

The 2024-2025 period has seen experimentation with LLM-assisted PoC generation:

- **Seed generation**: LLMs generate initial inputs based on understanding of binary protocols and APIs (used in AIxCC)
- **Harness generation**: LLMs draft fuzz harnesses from decompiled code (HarnessAgent, knowledge-driven approaches)
- **Exploit script drafting**: Given a vulnerability description and decompiled code, LLMs can draft pwntools exploit scripts (requires human verification)
- **Constraint hint generation**: LLMs suggest which symbolic variables and constraints are likely relevant, guiding symbolic execution

**Current limitations**: LLMs cannot reliably reason about precise memory layouts, pointer arithmetic, or constraint satisfaction. They serve best as *assistants* that reduce human effort rather than autonomous PoC generators.

---

## 7. Ghidra Integration Opportunities

This section maps each tool and technique to concrete Ghidra integration patterns.

### 7.1 Integration Architecture Options

| Integration Pattern | Mechanism | Latency | Complexity | Best For |
|---------------------|-----------|---------|------------|----------|
| **Ghidra Script (Java/Python)** | GhidraScript API; runs in-process | Low | Low-Medium | Simple analysis, UI interactions, one-off queries |
| **Ghidra Analyzer** | Custom Analyzer class; runs during auto-analysis | Low | Medium | Automatic annotation (add comments, bookmarks at vuln sites) |
| **Headless mode** | `analyzeHeadless` with pre/post scripts | Medium | Low | Batch processing, CI/CD integration, large-scale scanning |
| **PyGhidra (formerly Pyhidra)** | CPython access to Ghidra API via JPype | Low | Medium | Use Python ecosystem (angr, pwntools, ML libs) with Ghidra data |
| **Ghidra Bridge** | RPC bridge between Ghidra JVM and external Python | Medium | Medium | Real-time interaction between running Ghidra and external tools |
| **Plugin (Java module)** | Full Ghidra plugin with UI components | Low | High | Rich UI integration (tables, graphs, panels) |
| **BinExport + external tool** | Export Ghidra disassembly → process externally → import results | High | Medium | Tools with their own analysis engine (BinDiff, Joern, etc.) |

### 7.2 Taint Analysis Integration

**PANDA taint2 → Ghidra:**
- Run PANDA recording with taint2 plugin, export taint results
- `ida_taint2` already supports Ghidra: imports taint coloring as instruction-level annotations
- Enhancement opportunity: build a Ghidra plugin that renders taint flow as a navigable graph overlaid on the decompiler view

**Triton → Ghidra:**
- Use Ghidra Bridge or PyGhidra to extract function boundaries, call graph, and P-code
- Feed instruction bytes to Triton for symbolic+taint analysis
- Write results back as Ghidra comments, bookmarks, or custom highlights
- TritonDSE can be orchestrated from a Ghidra script for coverage-guided analysis

**angr taint/reaching_definitions → Ghidra:**
- Export binary via angr's `Project` loader
- Run `ReachingDefinitionsAnalysis` to compute def-use chains
- Map results back to Ghidra addresses; annotate as Ghidra comments/bookmarks
- angr-management (GUI) already visualizes some of this; Ghidra integration would bring it into the primary RE tool

### 7.3 AEG Integration

**Rex + Ghidra workflow:**
1. Analyst identifies a suspicious function in Ghidra
2. Script exports the binary path and target address to Rex
3. Rex runs crash exploration and exploit generation
4. Results (exploit type, controlled registers, generated payload) are imported back as Ghidra bookmarks/comments
5. If exploitation succeeds, the exploit script is saved alongside the Ghidra project

**Implementation**: A Ghidra plugin with a "Try Exploit" context menu action on functions/addresses. Uses PyGhidra to invoke Rex and angr, displays results in a custom Ghidra table.

### 7.4 ROP Chain Integration

**angrop + Ghidra:**
- angrop already uses angr, which can load the same binary Ghidra is analyzing
- A Ghidra script could: (1) identify the binary's gadgets via angrop, (2) display them in a Ghidra table with P-code/decompiler context, (3) allow the analyst to specify chain goals (e.g., "set rdi=addr, call system"), (4) generate and display the chain
- Enhancement: annotate gadget locations in the Listing view with their semantic effects

### 7.5 Binary Patching Integration

**Patcherex2 + Ghidra:**
- Use PyGhidra to access Ghidra's analysis (function boundaries, CFG, data references)
- Generate Patcherex2 patch specifications based on Ghidra analysis
- Apply patches and re-import the patched binary into Ghidra for verification
- A "Patch Wizard" plugin could guide the analyst through common patch patterns

**e9patch + Ghidra:**
- Export instrumentation specifications from Ghidra (addresses to instrument, code to insert)
- Generate e9tool scripts from Ghidra analysis
- Run e9patch externally and import the rewritten binary

### 7.6 Vulnerability Detection Integration

**BinAbsInspector**: Already a native Ghidra plugin. Integration opportunities:
- Improve checker coverage (add new CWE checkers)
- Connect findings to Ghidra's bookmark/comment system for triage workflow
- Add confidence scoring and false-positive suppression

**Joern/ghidra2cpg**: Already uses Ghidra as its binary frontend. Integration opportunities:
- Bidirectional: export CPG query results back to Ghidra as annotations
- Build a Ghidra plugin that launches Joern queries from the Ghidra UI
- Real-time: as the analyst navigates functions, run focused Joern queries

**Semgrep on decompiled output** (Sekiryu approach):
- Ghidra headless decompiles → Semgrep scans → results mapped back to addresses
- Enhancement: run in Ghidra's analysis pipeline as a post-analysis step

**BSim for vulnerability corpus search:**
- Build a BSim database of known-vulnerable library versions (e.g., vulnerable OpenSSL, glibc versions)
- When analyzing a new binary, query BSim for matches against the vulnerability corpus
- Annotate matched functions with CVE information and patch availability

### 7.7 Complete Ghidra-Centric Vulnerability Research Pipeline

```
Binary Input
     │
     ▼
Ghidra Auto-Analysis (headless or GUI)
     │
     ├──▶ BinAbsInspector (abstract interpretation vuln scan)
     │         │
     │         ▼
     │    Vuln candidates with addresses + CWE classification
     │
     ├──▶ BSim Query (similarity search against vuln corpus)
     │         │
     │         ▼
     │    Functions matching known-vulnerable patterns
     │
     ├──▶ ghidra2cpg → Joern (CPG queries for complex patterns)
     │         │
     │         ▼
     │    Taint-based findings (source → sink paths)
     │
     ├──▶ Decompile → Semgrep/CodeQL (pattern matching)
     │         │
     │         ▼
     │    Pattern-based findings
     │
     ▼
Triage (deduplicate, rank by severity/confidence)
     │
     ▼
Confirmation via Symbolic Execution (angr)
     │
     ├──▶ Crash → Rex (automatic exploitation attempt)
     │         │
     │         ▼
     │    Exploit PoC (if exploitable)
     │
     ▼
Remediation via Binary Patching (Patcherex2 / Ghidra Patch)
     │
     ▼
Patched Binary + Verification
```

---

## 8. Key Takeaways for Ghidra Integration

### High-Impact, Near-Term Opportunities

1. **BinAbsInspector revival and extension**: The existing Ghidra-native abstract interpretation plugin is the lowest-friction starting point. Extending it with additional CWE checkers, improved abstract domains, and better triage UX (severity scoring, false-positive suppression, connection to BSim results) would create a compelling built-in vulnerability scanner.

2. **BSim as a vulnerability knowledge base**: Building and maintaining curated BSim databases of known-vulnerable library functions (mapped to CVEs) transforms BSim from a general similarity tool into a targeted vulnerability search engine. This leverages existing Ghidra infrastructure with minimal new code.

3. **Joern/ghidra2cpg bidirectional bridge**: ghidra2cpg already uses Ghidra as its disassembly backend. Building a plugin that (a) launches Joern queries from the Ghidra UI and (b) imports results as navigable annotations would unite Ghidra's interactive RE workflow with Joern's powerful query language.

4. **Decompiler output → Semgrep/CodeQL pipeline**: Automating the "decompile → scan → map results back" workflow as a Ghidra Analyzer or post-analysis script provides lightweight vulnerability pattern matching with well-understood tools.

### Medium-Term Opportunities

5. **Taint visualization plugin**: Integrating PANDA taint2 or Triton taint results as a first-class visualization layer in Ghidra (color-coded decompiler/listing views, taint flow graphs) would provide dynamic taint evidence within the static RE environment.

6. **angr symbolic execution bridge**: A PyGhidra-based bridge that allows launching targeted symbolic execution (angr) from Ghidra -- e.g., "symbolically execute from function entry to this sink and check if input reaches it" -- would bring concolic PoC generation into the analyst's primary tool.

7. **ROP gadget browser**: A Ghidra plugin that uses angrop/ropbot to enumerate and classify gadgets, display them in a searchable table with decompiler context, and allow interactive chain construction would serve exploit developers working in Ghidra.

### Longer-Term / Research Opportunities

8. **Integrated AEG**: A "Try Exploit" action that chains Rex + angrop + pwntools from within Ghidra, taking the analyst from "suspicious crash" to "working PoC" with minimal manual intervention. This requires robust Rex improvements for real-world (non-CGC) binaries.

9. **LLM-assisted vulnerability triage**: Combining BinAbsInspector/Joern findings with LLM reasoning (via GhidrAssist or similar) to explain findings, assess exploitability, and draft remediation patches. Must include confidence scoring and audit trails for safety.

10. **Binary patch verification loop**: After applying a patch (via Patcherex2 or Ghidra's built-in patching), automatically re-run the vulnerability detection pipeline on the patched binary to verify the fix. This creates a closed-loop remediation workflow entirely within the Ghidra ecosystem.

### Architecture Principle

The common thread across all integration opportunities is: **Ghidra should be the analyst's primary workspace, with external tools (angr, Triton, Joern, PANDA, Patcherex2) accessible as services invoked from within Ghidra via PyGhidra, Ghidra Bridge, or headless scripting**. Results should flow back into Ghidra's annotation model (comments, bookmarks, highlights, custom tables) so that the analyst never needs to context-switch to a separate tool for the core workflow.

---

## References and Resources

### Tools and Repositories
- **angr**: https://angr.io/ | https://github.com/angr/angr
- **Rex**: https://github.com/angr/rex
- **angrop**: https://github.com/angr/angrop
- **Patcherex2**: https://github.com/purseclab/Patcherex2
- **e9patch**: https://github.com/GJDuck/e9patch
- **PANDA**: https://github.com/panda-re/panda
- **Triton**: https://github.com/JonathanSalwan/Triton
- **TritonDSE**: https://blog.quarkslab.com/introducing-tritondse
- **ROPgadget**: https://github.com/JonathanSalwan/ROPgadget
- **Ropper**: https://scoding.de/ropper/
- **ROPium**: https://github.com/Boyan-MILANOV/ropium
- **ropbot**: https://github.com/sefcom/ropbot
- **ropr**: https://github.com/Ben-Lichtman/ropr
- **rp++**: https://github.com/0vercl0k/rp
- **BinAbsInspector**: https://github.com/KeenSecurityLab/BinAbsInspector
- **Joern**: https://github.com/joernio/joern
- **ghidra2cpg**: https://github.com/joernio/ghidra2cpg
- **Zeratool**: https://github.com/ChrisTheCoolHut/Zeratool
- **VulHunt (Binarly)**: https://www.binarly.io/blog/vulhunt-intro
- **Sekiryu**: https://github.com/20urc3/Sekiryu
- **ghidra_SavePatch**: https://github.com/schlafwandler/ghidra_SavePatch
- **Ghidra BSim**: https://github.com/NationalSecurityAgency/ghidra (built-in)
- **LIEF**: https://github.com/lief-project/LIEF
- **fidget**: https://github.com/angr/fidget

### Key Papers
- Avgerinos et al., "AEG: Automatic Exploit Generation" (CCS 2011)
- Cha et al., "Unleashing Mayhem on Binary Code" (IEEE S&P 2012)
- Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis" (IEEE S&P 2016)
- Duck, G.J., "Binary Rewriting without Control Flow Recovery" (PLDI 2020) -- e9patch
- ropbot paper, "Reimagining Code Reuse Attack Synthesis" (NDSS 2026)
- DARPA AIxCC SoK (arXiv:2602.07666, 2025)
- Doberle, M., "An Empirical Comparison of Open-Source ROP-Chain Generators" (2024)
- Zetier, "CodeQL for Binaries: Auditing Them Like Source Code" (blog post)
- BinAbsInspector Wiki: https://github.com/KeenSecurityLab/BinAbsInspector/wiki/Technical-Details
- BSim Tutorial: https://github.com/NationalSecurityAgency/ghidra/blob/master/GhidraDocs/GhidraClass/BSim/BSimTutorial_Intro.md
