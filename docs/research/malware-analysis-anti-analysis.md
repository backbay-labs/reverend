# Malware Analysis Automation & Anti-Analysis Techniques

Research survey covering automated unpacking, anti-analysis detection/bypass,
behavioral analysis, malware classification, modern sandbox architectures,
Ghidra-specific malware tooling, and threat intelligence integration for
reverse engineering workflows.

Verification note (as of 2026-02-19): vendor sandbox capabilities, rule packs, and anti-analysis bypass success rates evolve rapidly; revalidate before operational use.

---

## 1. Automated Unpacking

Packing and compression are the first barrier in malware analysis. Automated
unpacking aims to recover the Original Entry Point (OEP) and reconstruct a
valid PE from the in-memory image after the unpacking stub executes.

### 1.1 Generic Unpacking via Emulation

#### Unipacker

- **Repository**: [unipacker/unipacker](https://github.com/unipacker/unipacker)
- Platform-independent automatic unpacker for Windows binaries using the
  Unicorn emulation engine.
- Emulates the unpacking stub, monitors execution, and dumps the unpacked
  binary when OEP is detected.
- Supports UPX, ASPack, PEtite, FSG, and YodaCrypt out of the box.
- **Limitations**: Designed for simpler packers; struggles with advanced
  commercial protectors (Themida, VMProtect, ASProtect) because their
  anti-emulation and virtualization layers defeat Unicorn's limited
  environment fidelity.
- OEP detection heuristic: monitors for jumps from non-executable stub
  sections into newly-written executable regions.

#### Qiling Framework

- **Repository**: [qilingframework/qiling](https://github.com/qilingframework/qiling)
- Higher-fidelity emulation framework built on Unicorn but providing OS-level
  abstraction (filesystem, registry, DLLs, syscalls).
- Unpacking workflow:
  1. Hook `VirtualAlloc` / `VirtualProtect` to track writable+executable regions.
  2. Set a code-execution callback; when execution enters a newly allocated
     region that was previously written to, flag it as a candidate OEP.
  3. Dump the process image and reconstruct PE headers using pefile.
- Advantage over bare Unicorn: OS-level emulation means API calls the
  unpacking stub depends on (e.g., `LoadLibrary`, `GetProcAddress`) can be
  handled, reducing premature crashes.
- Reference: Qiling Wiki, "Tutorial Unpacking Malware."

#### Pinicorn

- **Paper**: "Pinicorn: Towards Automated Dynamic Analysis for Unpacking
  32-Bit PE Malware" (Electronics, 2024, 13(11):2081).
- Uses Intel Pin for dynamic binary instrumentation rather than emulation.
- Specifically designed to handle Themida, VMProtect, and ASProtect, which
  defeat emulation-based unpackers.
- Detects and analyzes trampoline codes within both OEP and the Import
  Address Table (IAT), enabling full reconstruction.
- Uses four OEP heuristic algorithms (adapted from PinDemonium): Long Jump
  Heuristic, Jump Outer Section Heuristic, Entropy Heuristic, and YARA
  Heuristic.

### 1.2 OEP Detection Algorithms

| Algorithm | Technique | Best For |
|---|---|---|
| **Long Jump Heuristic** | Detects jumps >0x1000 bytes from current EIP to a new section | Simple redirect packers (UPX, ASPack) |
| **Jump Outer Section** | Flags execution leaving the stub's PE section | Multi-section packers |
| **Entropy Heuristic** | Monitors entropy drop in written regions (compressed -> decompressed) | Entropy-based packers |
| **YARA Heuristic** | Scans memory at candidate OEPs against known PE header/code signatures | Packers that restore standard headers |
| **Write-then-Execute** | Tracks W^X transitions: region written to, then executed | Generic; used by Qiling and Unipacker |

### 1.3 Memory Dumping and Reconstruction

#### PE-sieve

- **Repository**: [hasherezade/pe-sieve](https://github.com/hasherezade/pe-sieve)
- Passive memory scanner that detects and dumps in-memory implants from a
  running process by PID.
- Detection is artifact-based (not API-hooking), making it effective against
  novel injection techniques: process hollowing, process doppelganging,
  reflective DLL injection, shellcode injection, and in-memory patches/hooks.
- Reconstructs PE headers and attempts IAT rebuilding on dumped modules.
- Can produce JSON reports of all findings per process.
- Key design: fully passive scan -- does not hook the target process or
  interfere with execution.

#### Hollows Hunter

- **Repository**: [hasherezade/hollows_hunter](https://github.com/hasherezade/hollows_hunter)
- Command-line wrapper around PE-sieve that scans **all** running processes
  rather than a single PID.
- Workflow for unpacking: run the packed malware, then immediately run
  hollows_hunter to scan all processes and dump any with implants.
- Attempts to completely fix up dumped files and rebuild the IAT so they
  can be loaded into Ghidra/IDA for static analysis.
- Recent tutorial (March 2025): hasherezade demonstrated combined
  TinyTracer + PE-sieve workflows for automated unpacking.

#### Scylla (IAT Reconstruction)

- Standalone IAT reconstruction tool; commonly used in conjunction with
  debugger-based manual unpacking.
- After dumping at OEP, Scylla walks the IAT and resolves imports using
  the still-running process context.
- Works with x64dbg, OllyDbg, and standalone mode.

### 1.4 Packer-Specific Techniques

#### UPX

- **Standard**: `upx -d sample.exe` works for unmodified UPX binaries.
- **Modified UPX**: Malware authors commonly tamper with UPX magic bytes
  (`UPX!` header), section names (`.UPX0`/`.UPX1`), or version fields to
  break the standard unpacker. Fix: restore magic bytes or use emulation-
  based tools that do not rely on metadata.
- Identification: section names `.UPX0`/`.UPX1`, or entropy profile showing
  one high-entropy and one near-zero section.

#### Themida / WinLicense

- Commercial protector using code virtualization: converts x86 instructions
  into a custom randomized virtual instruction set, interpreted at runtime
  by an embedded VM.
- Anti-analysis: extensive anti-debug, anti-VM, anti-dump, code mutation,
  and nanomites.
- Automated approaches: Pinicorn (Pin-based); DBI tools (Frida, Intel Pin)
  to trace execution and reconstruct original code flow.
- Manual approach: identify the VM dispatcher loop, trace virtual handlers,
  reconstruct semantics.
- Reference: "Bypassing Anti-Analysis of Commercial Protector Methods Using
  DBI Tools" (ResearchGate, 2021).

#### VMProtect

- Virtualizing protector similar to Themida but with a different VM
  architecture and anti-analysis suite.
- Recent research (2025): "VMProtect Devirtualization" series by hackyboiz
  demonstrates extracting virtual instruction semantics and mapping them
  back to native instructions.
- **X64Unpack**: Hybrid emulation unpacker for 64-bit environments with
  detailed analysis on VMProtect 3.4 (ResearchGate).
- Devirtualization remains an active research area; no fully automated
  public tool achieves complete VMProtect devirtualization.

### 1.5 Ghidra Scripts for Unpacking Assistance

- **Emotet unpacking**: [AllsafeCyberSecurity/malware-analysis-at-scale-defeating-emotet-by-ghidra](https://github.com/AllsafeCyberSecurity/malware-analysis-at-scale-defeating-emotet-by-ghidra)
  -- Ghidra script for automated Emotet analysis and config extraction.
- **General malware scripts**: [AllsafeCyberSecurity/ghidra_scripts](https://github.com/AllsafeCyberSecurity/ghidra_scripts)
  -- Collection of Ghidra scripts for malware analysis tasks including
  string decryption, API resolution, and code deobfuscation.
- **Headless unpacking pipeline**: Use Ghidra's Headless Analyzer to import
  a dumped binary (from PE-sieve/hollows_hunter), run auto-analysis, then
  execute post-scripts for string extraction and capability detection.
- **P-code emulation for decryption**: Ghidra's built-in PcodeEmulator can
  emulate small decryption routines in-situ to resolve encrypted strings
  and configuration data without running the malware.

---

## 2. Anti-Analysis Detection and Bypass

Malware employs anti-analysis techniques to detect and evade debuggers,
virtual machines, emulators, and sandboxes. Understanding these techniques
is essential for building automated analysis pipelines that are resilient
to evasion.

### 2.1 Anti-Debug Techniques

#### API-Based Detection

| Technique | API / Mechanism | Detection Method |
|---|---|---|
| **IsDebuggerPresent** | Reads `PEB.BeingDebugged` flag | Checks `fs:[30h]+2` (x86) or `gs:[60h]+2` (x64) |
| **CheckRemoteDebuggerPresent** | Calls `NtQueryInformationProcess` internally | ProcessDebugPort class (0x07) |
| **NtQueryInformationProcess** | Direct ntdll syscall | ProcessDebugPort, ProcessDebugFlags (0x1F), ProcessDebugObjectHandle (0x1E) |
| **NtQuerySystemInformation** | SystemKernelDebuggerInformation class | Detects kernel debuggers (WinDbg) |
| **OutputDebugString** | Sets last error if no debugger attached | Error code check after call |
| **NtSetInformationThread** | ThreadHideFromDebugger (0x11) | Makes thread invisible to debugger, suppressing breakpoint exceptions |
| **NtClose (invalid handle)** | CloseHandle with invalid handle | Under debugger: raises EXCEPTION_INVALID_HANDLE; without: returns error |

#### Timing Checks

- **RDTSC**: Read Time Stamp Counter -- measures CPU cycles between two
  points. Debugger single-stepping inflates the cycle count enormously.
- **QueryPerformanceCounter / GetTickCount**: Higher-level timing APIs;
  same principle.
- **NtQueryPerformanceCounter**: Direct syscall variant.
- Threshold: legitimate execution of a small code block might take <1000
  cycles; debugger stepping can inflate to >100,000 cycles.
- Bypass: patch the comparison, or use ScyllaHide to normalize timing
  returns.

#### Hardware Breakpoint Detection

- **GetThreadContext**: Reads debug registers (DR0-DR3) which hold hardware
  breakpoint addresses; non-zero values indicate a debugger.
- **NtGetContextThread**: Direct syscall variant.
- **SetUnhandledExceptionFilter**: Triggers an exception and checks if the
  filter runs (it won't under a debugger that handles the exception first).
- Bypass: ScyllaHide clears debug registers in the returned context.

#### TLS Callbacks

- Thread Local Storage (TLS) callbacks execute **before** the main entry
  point, making them ideal for early anti-debug checks.
- Malware registers TLS callbacks in the PE's TLS directory; the callback
  runs on DLL_PROCESS_ATTACH before `main()` or `WinMain()`.
- Debuggers that break at the entry point miss the TLS callback execution.
- Bypass: configure the debugger to break on TLS callbacks (x64dbg: Options
  -> Preferences -> Events -> TLS Callbacks), or use ScyllaHide to skip
  them.

#### Self-Debugging and Parent Process Checks

- **Self-debugging**: Malware calls `DebugActiveProcess` on itself; if a
  debugger is already attached, the call fails (only one debugger per
  process).
- **Parent process check**: Compares parent PID against expected explorer.exe
  PID; if the parent is a debugger (x64dbg, IDA, etc.), the malware changes
  behavior.
- **Process enumeration**: Scans running processes for known debugger names
  (ollydbg.exe, x64dbg.exe, ida.exe, ida64.exe, ghidra.exe, etc.).

### 2.2 Anti-VM Techniques

#### CPUID Instruction

- `CPUID` with `EAX=1`: Bit 31 of ECX (hypervisor present bit) is set to 1
  in a VM, 0 on physical hardware.
- `CPUID` with `EAX=0x40000000`: Returns a 12-byte hypervisor ID string in
  EBX/ECX/EDX (e.g., "VMwareVMware", "Microsoft Hv", "KVMKVMKVM").
- Bypass: modify the hypervisor's CPUID leaf response (VMware:
  `cpuid.1.ecx="---0-"` in VMX; VirtualBox: `VBoxManage modifyvm --paravirtprovider none`).

#### Registry and File System Checks

| Artifact | VM Indicator |
|---|---|
| `HKLM\SOFTWARE\VMware, Inc.\VMware Tools` | VMware |
| `HKLM\SOFTWARE\Oracle\VirtualBox Guest Additions` | VirtualBox |
| `HKLM\SYSTEM\CurrentControlSet\Services\VBoxGuest` | VirtualBox driver |
| `C:\Windows\System32\drivers\vmmouse.sys` | VMware mouse driver |
| `C:\Windows\System32\drivers\VBoxMouse.sys` | VirtualBox mouse driver |
| `C:\Program Files\VMware\VMware Tools` | VMware Tools directory |

#### MAC Address Prefix Detection

| Prefix | Vendor |
|---|---|
| `00:0C:29`, `00:50:56` | VMware |
| `08:00:27` | VirtualBox |
| `00:03:FF` | Hyper-V |
| `00:16:3E` | Xen |
| `52:54:00` | QEMU/KVM |

#### Hardware and Driver Checks

- **Disk size**: VMs often have small disks (<80 GB).
- **RAM size**: VMs often allocated <4 GB.
- **CPU core count**: VMs often have 1-2 cores.
- **Screen resolution**: VMs may use non-standard resolutions.
- **USB device enumeration**: Lack of USB devices suggests VM.
- **Firmware tables**: SMBIOS/ACPI tables contain VM vendor strings.
- **I/O port probes**: VMware backdoor I/O port (`in eax, dx` with
  `dx=0x5658` and magic `EAX=0x564D5868`).

#### Reference: al-khaser

- **Repository**: [ayoubfaouzi/al-khaser](https://github.com/ayoubfaouzi/al-khaser)
- Comprehensive open-source collection of public malware techniques for
  VM, emulation, debugger, and sandbox detection.
- Serves as both a reference and a test suite for verifying anti-anti-
  analysis tool coverage.

### 2.3 Anti-Emulation Techniques

- **Unsupported instruction execution**: Emulators may not implement all
  x86 instructions (e.g., SSE4, AVX, obscure FPU states). Malware executes
  rare instructions and checks results.
- **Environment fidelity**: Check for realistic PEB fields, TEB fields,
  loaded DLL lists, environment variables, and system directory contents
  that emulators may not fully populate.
- **API result validation**: Call APIs like `GetSystemMetrics`,
  `GetComputerName`, `GetUserName` and verify results are plausible (not
  generic emulator defaults).
- **Timing-based**: Emulation is orders of magnitude slower than native
  execution; RDTSC checks detect this.
- **Memory layout**: Check for expected DLL base addresses, heap layout
  characteristics, and stack positioning that differ in emulated
  environments.

### 2.4 Anti-Sandbox Techniques

- **Sleep / delayed execution**: `Sleep(300000)` or equivalent to outlast
  sandbox time limits (typically 60-120 seconds). Modern sandboxes
  accelerate sleep calls.
- **User interaction requirements**: Check for mouse movement, keyboard
  input, window click events, or scroll wheel activity before executing
  payload. ANY.RUN provides interactive sessions to defeat this.
- **Process/username checks**: Look for sandbox-specific usernames
  ("sandbox", "malware", "test", "cuckoo") and process names.
- **Document bait**: Office macro malware checks if a document has >3 pages,
  has been edited, or contains realistic content.
- **Network checks**: Attempt DNS resolution or HTTP requests to known
  domains; if all resolve to the same IP (sandbox DNS interception), abort.
- **Geofencing**: Check system locale, timezone, keyboard layout, or IP
  geolocation to target specific regions.

### 2.5 Bypass Tools

#### ScyllaHide (User-Mode)

- **Repository**: [x64dbg/ScyllaHide](https://github.com/x64dbg/ScyllaHide)
- Advanced user-mode anti-anti-debugger library.
- Hooks multiple NT-level functions to hide debugging:
  - `NtQueryInformationProcess` (debug port, debug flags, debug object)
  - `NtQuerySystemInformation` (kernel debugger info)
  - `NtSetInformationThread` (hide from debugger)
  - `NtClose` (invalid handle exception)
  - `GetTickCount` / `NtQueryPerformanceCounter` (timing normalization)
  - `NtGetContextThread` (clears hardware breakpoints from reported context)
  - `BlockInput` (prevents input blocking)
- Supports OllyDbg, x64dbg, IDA Pro, and standalone DLL injection mode.
- Profile system: "VMProtect", "Themida", "Everything" profiles configure
  which hooks to activate.

#### TitanHide (Kernel-Mode)

- Kernel-mode driver that intercepts SSDT (System Service Descriptor Table)
  calls at ring 0.
- Hides debug objects and debug ports at the kernel level, defeating
  anti-debug techniques that bypass user-mode hooks by issuing direct
  syscalls.
- Necessary when malware uses direct `syscall`/`sysenter` instructions to
  call NtQueryInformationProcess, bypassing ScyllaHide's user-mode hooks.
- Requires driver signing bypass or test-signing mode.

#### WubbabooMark

- **Repository**: [hfiref0x/WubbabooMark](https://github.com/hfiref0x/WubbabooMark)
- Debugger anti-detection benchmark tool.
- Tests the effectiveness of anti-anti-debug tools (ScyllaHide, TitanHide)
  against a comprehensive suite of detection techniques.
- Useful for validating analysis environment hardening.

---

## 3. Behavioral Analysis

Dynamic behavioral analysis captures what malware actually does at runtime:
API calls, syscalls, file/registry modifications, network communications,
and process interactions.

### 3.1 API Monitoring

#### API Monitor (rohitab)

- **URL**: rohitab.com/apimonitor
- Intercepts and logs Win32 API calls for any running process.
- Provides a comprehensive API definition database covering 13,000+ APIs
  across 200+ DLLs.
- Features: call tree visualization, buffer/structure decoding, filter by
  DLL/API name, 32-bit and 64-bit support.
- Useful for rapid triage: watch `CreateFile`, `RegSetValue`, `connect`,
  `WriteProcessMemory` to characterize behavior.

#### Frida Hooks

- **URL**: [frida.re](https://frida.re/)
- Dynamic binary instrumentation framework for Windows, macOS, Linux,
  Android, iOS, and more.
- JavaScript-based scripting engine injected into target process.
- Malware analysis workflow:
  1. Attach to running malware process or spawn with Frida.
  2. Use `Interceptor.attach()` to hook APIs of interest.
  3. Log arguments, return values, and call stacks in `onEnter`/`onLeave`.
  4. Modify arguments or return values to bypass checks or trigger
     specific code paths.
- **frida-trace**: Command-line tool that auto-generates hook scripts for
  specified API patterns (e.g., `frida-trace -i "Crypt*" malware.exe`).
- Advantages over API Monitor: cross-platform, scriptable, can modify
  behavior, supports remote devices.
- Can be combined with Qiling for emulation + instrumentation workflows.
- Reference: BlackBerry, "Malware Analysis with Dynamic Binary
  Instrumentation Frameworks" (2021).

#### ETW (Event Tracing for Windows)

- Built-in Windows kernel/user tracing framework.
- Captures syscalls, process creation/termination, file I/O, registry
  operations, network activity, DLL loads, and more.
- **Key providers for malware analysis**:
  - `Microsoft-Windows-Kernel-Process` (process/thread events)
  - `Microsoft-Windows-Kernel-File` (file operations)
  - `Microsoft-Windows-Kernel-Registry` (registry modifications)
  - `Microsoft-Windows-Kernel-Network` (network connections)
  - `Microsoft-Antimalware-Scan-Interface` (AMSI events)
  - `Microsoft-Windows-DNS-Client` (DNS queries)
- **Etw-SyscallMonitor**: [jdu2600/Etw-SyscallMonitor](https://github.com/jdu2600/Etw-SyscallMonitor)
  -- Monitors ETW for security-relevant syscalls per unique process.
- **Evasion concern**: Advanced malware (e.g., Remcos RAT, Feb 2025)
  patches `EtwEventWrite` in ntdll.dll to disable ETW logging. Direct
  syscall techniques also bypass many ETW providers.
- **Kernel ETW call stacks**: Elastic Security Labs (2025) demonstrated
  using kernel-level ETW with call stack capture to detect in-memory
  threats that bypass user-mode ETW.

### 3.2 Syscall Tracing

| Tool | Platform | Technique | Notes |
|---|---|---|---|
| **strace** | Linux | ptrace-based syscall interception | Logs all syscalls with args; standard Linux malware triage |
| **ltrace** | Linux | PLT hooking for library calls | Traces shared library calls (libc, etc.) |
| **drstrace** | Windows | DynamoRIO-based instrumentation | strace equivalent for Windows; logs NT syscalls |
| **DTrace** | Windows/macOS/Solaris | Kernel tracing framework | Windows 10 1903+; `syscall:::entry` probes |
| **Process Monitor** | Windows | Kernel driver (filter driver) | Microsoft tool; file/registry/process/network in real-time |

### 3.3 Network Capture and Simulation

#### FakeNet-NG

- **Repository**: [mandiant/flare-fakenet-ng](https://github.com/mandiant/flare-fakenet-ng)
- Mandiant FLARE's next-generation dynamic network analysis tool.
- Intercepts and redirects all network traffic while simulating legitimate
  services: HTTP, HTTPS, DNS, SMTP, FTP, IRC, and custom protocols.
- Captures traffic in PCAP files; preserves HTTP POST payloads separately.
- Provides network IOCs: URLs, User-Agents, beacon payloads, C2 domains.
- Supports Windows natively; Linux support for certain modes.
- FakeNet Genie (2019+): cheat-code system for configuring custom response
  patterns to elicit specific malware behaviors.

#### INetSim

- **URL**: inetsim.org
- Linux-based Internet services simulation suite.
- Simulates DNS, HTTP, HTTPS, FTP, SMTP, POP3, IRC, NTP, and more.
- Typically runs on a separate Linux machine or VM providing network
  services to the analysis VM.
- Commonly used in REMnux-based analysis environments.
- Complements FakeNet-NG; INetSim is preferred for isolated network labs,
  FakeNet-NG for single-host analysis.

#### Network Analysis Comparison

| Tool | Platform | Mode | Key Strength |
|---|---|---|---|
| **FakeNet-NG** | Windows/Linux | Single-host interception | Transparent; no separate machine needed |
| **INetSim** | Linux | Dedicated service simulation | Full protocol simulation suite |
| **mitmproxy** | Cross-platform | HTTPS interception proxy | TLS interception with certificate injection |
| **Wireshark/tshark** | Cross-platform | Passive capture | Deep protocol dissection |
| **PCAP-NG analysis** | N/A | Post-capture | Suricata/Snort IDS rules on captures |

### 3.4 Sandbox Integration Patterns

Behavioral analysis tools integrate into automated pipelines:

1. **Ingest**: Submit sample to CAPE/ANY.RUN/Joe Sandbox via API.
2. **Detonate**: Sandbox executes sample in instrumented VM.
3. **Capture**: API traces, network PCAP, memory dumps, dropped files.
4. **Extract**: Config extraction, payload dumping, IOC harvesting.
5. **Classify**: Run capa (static + dynamic rules) on results.
6. **Report**: STIX 2.1 bundle with ATT&CK mappings, YARA matches.
7. **Triage**: Route to Ghidra headless pipeline for deep static analysis
   of extracted payloads.

---

## 4. Malware Classification and Clustering

### 4.1 Machine Learning Approaches

#### Feature Extraction Methods

| Feature Type | Examples | Pros | Cons |
|---|---|---|---|
| **Byte n-grams** | Raw byte sequences (1-8 grams) | Simple, no disassembly needed | High dimensionality; packing defeats it |
| **Opcode sequences** | Disassembled instruction mnemonics | Captures code structure | Requires disassembly; obfuscation-sensitive |
| **API call sequences** | Dynamic API trace patterns | Behavior-oriented; packing-resistant | Requires execution; incomplete coverage |
| **Control flow graphs** | CFG structure features (node/edge counts, cycles) | Structural similarity | Graph comparison is expensive |
| **PE header features** | Section entropy, import counts, timestamps | Fast; no execution needed | Easily manipulated |
| **Function embeddings** | Neural embeddings (Gemini, jTrans, CLAP) | Semantic similarity | Model training/inference cost |

#### Classification Models

- **Random Forest / Gradient Boosting**: Standard ML on PE header and
  n-gram features. Fast inference, interpretable. Used in production by
  CylancePROTECT (early ML-AV).
- **CNN on raw bytes**: MalConv (2018) processes raw bytes through a
  CNN for classification without feature engineering. Subsequent work
  improved scalability.
- **RNN/LSTM on API sequences**: Models sequential API call patterns as
  time series. Effective for behavioral classification.
- **GNN on call graphs / CFGs**: Graph neural networks on program
  structure. Cross-architecture potential.
- **Transformer models**: Fine-tuned language models on disassembly or
  decompiled code for family classification. Recent work applies
  instruction-level transformers (PalmTree, jTrans architectures) to
  malware classification.

#### Zipf-Gramming (2025)

- Recent approach for scaling byte n-gram analysis to production-sized
  malware corpora.
- Uses Zipf's law properties of byte n-gram distributions to reduce
  feature dimensionality while preserving discriminative power.

### 4.2 Automated YARA Rule Generation

#### AutoYara (Booz Allen, 2020)

- Uses biclustering ML algorithms to identify which n-grams cluster
  together across a malware family.
- Produces YARA rules automatically from a set of related samples.
- Workflow: extract n-grams -> bicluster to find shared patterns ->
  generate YARA conditions with appropriate thresholds.
- Reference: "Automatic Yara Rule Generation Using Biclustering"
  (AISec 2020, ACM).

#### YARA-Signator (Malpedia)

- **Repository**: Integrated with [Malpedia](https://malpedia.caad.fkie.fraunhofer.de/)
- Automatically generates code-based YARA rules from Malpedia's curated
  malware corpus.
- Rules are based on distinctive code sequences rather than string
  artifacts, making them more resilient to minor variants.
- Synchronized repositories allow teams to pull updated rule sets.

#### ML-Driven Pipeline (2026)

- "A ML-Driven Pipeline for Automated YARA Rule Extraction and Malware
  Detection" (Springer, 2026) demonstrates end-to-end pipeline from
  sample ingestion through feature extraction to YARA rule generation
  and validation.

#### yarGen / yarAnalyzer

- **yarGen**: Generates YARA rules from strings and opcodes found in
  malware samples using a goodware string database to reduce false
  positives.
- **yarAnalyzer**: Evaluates YARA rule quality against sample sets.

### 4.3 Function-Level Clustering for Family Identification

- **Approach**: Extract function-level features (embeddings, CFG hashes,
  API call patterns) and cluster functions across a corpus.
- **Shared code detection**: Identifies common libraries, shared builders,
  and code reuse across malware families.
- **BSim for clustering**: Ghidra's BSim (see Section 6.5) can index
  functions from known malware families and query new samples against the
  database to identify family membership.
- **Kam1n0**: Assembly clone search engine using Asm2Vec embeddings;
  supports function-level clustering across large repositories.
- **BinDiff-based clustering**: Export function hashes via BinExport, then
  cluster by function similarity scores.
- **Frequent API itemsets**: Clustering based on frequent API call
  subsequences identifies behavioral families regardless of code-level
  changes.

### 4.4 Intelligence Feeds and Reference Databases

| Resource | Type | Access | Key Value |
|---|---|---|---|
| **Malpedia** | Curated malware corpus | Free (CAAD/Fraunhofer) | Reference samples, YARA rules, family tracking |
| **VirusTotal** | Multi-scanner + intelligence | API (commercial tiers) | Reputation, relationships, behavioral reports |
| **OPSWAT MetaDefender** | Multi-scanner + deep CDR | API (commercial) | File sanitization + 30+ AV engines |
| **MalwareBazaar** | Sample sharing | Free (abuse.ch) | Community-sourced samples with tags |
| **Malshare** | Sample repository | Free (API key) | Bulk sample access for research |
| **vx-underground** | Historical malware archive | Free | Papers, samples, APT collections |
| **ReversingLabs TitaniumCloud** | File intelligence | Commercial API | Deep file metadata, YARA hunting |

---

## 5. Modern Sandboxes

### 5.1 Architecture Comparison

| Feature | CAPE | ANY.RUN | Joe Sandbox | Triage (Hatching) |
|---|---|---|---|---|
| **Deployment** | Self-hosted (open source) | Cloud SaaS | Cloud + on-prem | Cloud SaaS |
| **License** | Open source (GPLv3) | Commercial (free tier) | Commercial | Commercial (free tier) |
| **OS Support** | Windows (primary), Linux | Windows | Windows, Linux, macOS, Android, iOS | Windows, Linux, Android |
| **Interaction** | Automated | Interactive real-time | Automated | Automated |
| **Config Extraction** | 300+ families | Limited | Extensive | Growing |
| **Payload Dumping** | Native (core feature) | Via memory dumps | Yes | Yes |
| **API Traces** | Full (via monitor DLL) | Full (interactive) | Full | Full |
| **PCAP Capture** | Yes | Yes | Yes | Yes |
| **YARA Integration** | Dynamic YARA scanning | Static + behavioral | Yes | Yes |
| **ATT&CK Mapping** | Via capa integration | Native | Native | Native |
| **API Access** | REST API | REST API | REST API | REST API |
| **Evasion Detection** | YARA-based anti-sandbox bypass | Interactive defeats many | Behavior-based detection | Configurable |
| **Cost** | Free (infra costs) | $2,388+/yr (paid) | ~$4,800+/yr (varies) | ~$300+/mo |

### 5.2 CAPE Sandbox (Deep Dive)

- **Repository**: [kevoreilly/CAPEv2](https://github.com/kevoreilly/CAPEv2)
- Evolution of Cuckoo Sandbox, specializing in **Configuration And Payload
  Extraction** (hence the name).
- Core differentiator: programmable debugger integrated into the sandbox.
  YARA rules can trigger breakpoints and debugger actions during detonation,
  enabling dynamic bypass of anti-sandbox techniques.
- **Dynamic YARA scanning**: Added in 2021; YARA scans run during execution,
  not just post-analysis. This enables:
  - Setting breakpoints when specific packed/encrypted code patterns are
    detected in memory.
  - Dumping payloads at the exact moment of decryption.
  - Bypassing anti-analysis checks dynamically.
- Config extraction supports 300+ malware families (Emotet, TrickBot,
  QakBot, AgentTesla, Formbook, etc.).
- **Dynamic capa integration**: capa v7.0 can analyze CAPE sandbox reports
  to identify capabilities from behavioral traces, not just static analysis.
  This extends capa's 800+ rules to runtime behavior.
- Custom signatures can be written in Python following Cuckoo's signature
  framework pattern.

### 5.3 ANY.RUN

- **URL**: [any.run](https://any.run/)
- Key differentiator: **interactive** sandbox. Analysts can click, type,
  scroll, and interact with the malware in real-time through a browser.
- Defeats user-interaction-dependent evasion techniques (mouse movement
  checks, click requirements).
- Real-time process tree, network activity, and file system changes visible
  during execution.
- Threat Intelligence (TI) Lookup: search IOCs across all public submissions.
- YARA search across the submission corpus.
- Free tier: limited public submissions; paid tiers add private analysis,
  API access, and longer execution times.

### 5.4 Joe Sandbox

- **URL**: joesecurity.org
- Multi-platform: Windows, macOS, Linux, Android, iOS analysis.
- **Joe Sandbox AI** (June 2025): integrated AI-powered analysis for
  automated report summarization and threat classification.
- Deep analysis: 750+ behavioral signatures, phishing detection, document
  exploit detection.
- Hybrid analysis: combines static + dynamic + network analysis.
- On-premise deployment option for classified/airgapped environments.

### 5.5 Triage (Hatching)

- **URL**: tria.ge
- Designed for high-throughput automated triage.
- Family detection and config extraction for common malware families.
- Fast turnaround: optimized for quick verdicts rather than deep analysis.
- Community edition with public submissions; commercial API for private use.
- Integrates with MISP and other TI platforms for automated enrichment.

### 5.6 Evasion Detection Capabilities

Modern sandboxes employ counter-evasion:

- **Sleep acceleration**: Intercept `Sleep`/`NtDelayExecution` and fast-
  forward time. CAPE's monitor DLL patches sleep calls.
- **Fake user activity**: Simulate mouse movement, keyboard input, window
  focus changes. ANY.RUN uses real interaction instead.
- **Environment hardening**: Realistic hostnames, usernames, MAC addresses,
  disk sizes, installed software. Hide VM artifacts.
- **Anti-evasion YARA**: CAPE scans for known evasion patterns and bypasses
  them at the debugger level.
- **Extended execution**: Joe Sandbox supports extended execution times
  (up to 10 minutes+) to outlast sleep-based evasion.

---

## 6. Ghidra for Malware Analysis

### 6.1 capa Integration (Capability Detection)

- **Repository**: [mandiant/capa](https://github.com/mandiant/capa)
- capa identifies capabilities in executable files using a rule-based system
  with 800+ community-maintained rules.
- Rules are written in a custom YAML format specifying combinations of API
  calls, strings, constants, and code patterns that indicate specific
  capabilities (e.g., "encrypt data using AES", "persist via scheduled
  task", "capture screenshot").

#### Ghidra Integration (capa v7+)

- **capa_explorer.py**: Renders capa results directly in Ghidra's UI.
  - Adds matched capabilities to Ghidra's **Symbol Tree** under a capa
    namespace for quick navigation.
  - Adds matched capabilities to **Bookmarks** for persistent tracking.
  - Annotates functions with **pre-comments** listing matched capabilities
    and features.
- **capa_ghidra.py**: Headless-compatible script for batch processing.
  - Command: `analyzeHeadless <project> <name> -Import <sample> -PostScript capa_ghidra.py "<rules_path>"`
  - Outputs capability matches to terminal; suitable for pipeline integration.
- **Implementation**: Written in Python 3 using Ghidrathon (Jep-based
  Python 3 extension for Ghidra).
- **Dependency**: Requires Ghidrathon installed and configured.
- Reference: "Riding Dragons: capa Harnesses Ghidra" (Mandiant/Google
  Cloud Blog, 2023).

#### Dynamic capa (capa v7+)

- Extends capa to analyze CAPE sandbox behavioral reports.
- Same rule format; rules can match on dynamic API call sequences observed
  during sandbox execution.
- Enables capability detection on packed/encrypted samples that resist
  static analysis.
- Pipeline: submit to CAPE -> retrieve JSON report -> run capa with
  `--format cape` -> get behavioral capability matches.

### 6.2 FLOSS for String Extraction

- **Repository**: [mandiant/flare-floss](https://github.com/mandiant/flare-floss)
- FLARE Obfuscated String Solver: automatically extracts obfuscated strings
  from malware.
- Techniques:
  1. **Static strings**: Standard string extraction (like `strings`).
  2. **Stack strings**: Detects strings built character-by-character on the
     stack via `mov` instructions.
  3. **Tight strings**: Identifies strings constructed in tight loops.
  4. **Decoded strings**: Emulates decoding functions to extract runtime-
     decrypted strings (uses Unicorn/vivisect for emulation).
- FLOSS does not directly integrate with Ghidra but its output (JSON) can
  be imported into Ghidra as comments/labels via scripting.
- Workflow: run FLOSS -> import results into Ghidra -> annotate functions
  with decoded string context.

### 6.3 Existing Ghidra Malware Analysis Scripts

#### AllsafeCyberSecurity Collection

- **ghidra_scripts**: General malware analysis scripts (string decryption,
  API hashing resolution, shellcode analysis).
- **Emotet-specific**: Automated analysis and config extraction for Emotet
  variants using Ghidra's headless analyzer.

#### galoget/ghidra-headless-scripts

- **Repository**: [galoget/ghidra-headless-scripts](https://github.com/galoget/ghidra-headless-scripts)
- Collection of headless analyzer scripts for automated decompilation and
  disassembly, designed for batch processing.

#### AskJOE (Security Joes)

- **Repository**: [securityjoes/AskJOE](https://github.com/securityjoes/AskJOE)
- AI-powered malware analysis and threat intelligence plugin for Ghidra.
- Uses LLM integration for function explanation, malware detection hints,
  and threat intelligence lookups.
- Demonstrates the intersection of AI-assisted RE and malware analysis.

#### Common Ghidra Scripting Patterns for Malware

```java
// API hash resolution: resolve hashed imports
// Walk through XREFs to the hash-lookup function,
// extract the hash constant, look it up in a known
// API hash database, and rename the resolved function.

// String decryption: identify XOR/RC4/custom decrypt
// functions, extract key and ciphertext from call sites,
// emulate or compute the decryption, add result as comment.

// Shellcode analysis: create a new memory block at a fixed
// base, import raw shellcode, define entry point, run
// auto-analysis, then annotate API calls resolved via
// PEB walking / hash-based import resolution.
```

### 6.4 Headless Triage Pipelines

Architecture for automated malware triage with Ghidra:

```
Sample Ingestion
    |
    v
[PE-sieve / hollows_hunter] --> Dump unpacked binaries
    |
    v
[Ghidra Headless Analyzer]
    |-- Import binary
    |-- Auto-analysis (all analyzers)
    |-- PostScript: capa_ghidra.py (capability detection)
    |-- PostScript: custom string decryptor
    |-- PostScript: API hash resolver
    |-- PostScript: export decompilation (JSON/XML)
    |
    v
[capa static + dynamic results]
    |
    v
[YARA rule matching on extracted artifacts]
    |
    v
[Report generation: STIX 2.1 bundle + ATT&CK mapping]
    |
    v
[MISP submission / Ghidra Server shared project]
```

Key headless analyzer flags:
- `-import <file>`: Import binary into project.
- `-postScript <script> <args>`: Run script after analysis.
- `-preScript <script>`: Run script before analysis.
- `-process <program>`: Process an already-imported program.
- `-recursive`: Process all files in a directory.
- `-analysisTimeoutPerFile <seconds>`: Prevent hangs on large binaries.
- `-deleteProject`: Clean up project after processing.
- `-noanalysis`: Import without running analyzers (for custom analysis).

### 6.5 BSim for Malware Family Correlation

- **Documentation**: [GhidraDocs/GhidraClass/BSim](https://github.com/NationalSecurityAgency/ghidra/tree/master/GhidraDocs/GhidraClass/BSim)
- BSim finds structurally similar functions across large binary collections
  using feature vectors derived from Ghidra's decompiler and P-code
  representation.

#### How BSim Works

1. **Feature extraction**: For each function, BSim generates a feature
   vector based on the decompiled P-code representation plus additional
   observations (constants, call patterns).
2. **Vector storage**: Vectors are stored in a database (H2 for local,
   PostgreSQL or Elasticsearch for server deployments).
3. **Similarity search**: Given a query function, BSim computes cosine
   similarity against all vectors in the database.
4. **Cross-compilation resilience**: Because features are derived from
   P-code (architecture-neutral IR), BSim can match functions across
   different compilers, optimization levels, and architectures.

#### Malware Analysis Applications

- **Family tracking**: Index functions from known variants of a malware
  family. When a new sample appears, query BSim to identify which functions
  match known family code and which are new.
- **Shared code/builder detection**: Identify code shared across seemingly
  unrelated malware families (shared builders, common libraries, purchased
  crypters).
- **Variant diffing**: Compare two versions of a malware family to identify
  which functions changed, were added, or removed.
- **Library identification at scale**: Build BSim databases of common
  libraries (OpenSSL, zlib, etc.) to identify statically linked library
  code in malware.

#### Database Backends

| Backend | Use Case | Scale |
|---|---|---|
| **H2** | Local/single-analyst | Small corpora (<10K functions) |
| **PostgreSQL** | Team server | Medium-large corpora |
| **Elasticsearch** | Large-scale deployment | Millions of functions |

#### Recent Research (BAR 2025)

- "Ghidra: Is Newer Always Better?" (Crussell, Sandia National Laboratories,
  NDSS BAR 2025) examines how pairwise BSim similarity changes across
  Ghidra versions when importing the same Malpedia samples, providing
  insights into analysis stability.

### 6.6 Ghidra Server for Team Malware Analysis

- **Server setup**: Ghidra Server enables shared repositories with version
  control (check-out/check-in/merge model).
- **Workflow for malware teams**:
  1. Analyst A imports and performs initial triage, checks in with
     annotations (capa results, string decryptions, API resolutions).
  2. Analyst B checks out the same program, adds behavioral analysis
     annotations from sandbox results, checks in.
  3. Merge conflicts resolved through Ghidra's built-in merge tool.
  4. All annotations, type definitions, and comments are versioned.
- **Exclusive checkout**: Available when only one analyst should edit at a
  time (prevents merge conflicts at the cost of concurrency).
- **BSim integration**: Shared BSim databases (PostgreSQL/Elasticsearch)
  complement the Ghidra Server by providing corpus-wide similarity search
  accessible to all team members.
- **Version 11.3 (2025)**: Added kernel-level debugging, JIT P-code
  emulation, VSCode integration, and enhanced function graph layouts.

---

## 7. Threat Intelligence Integration

### 7.1 STIX/TAXII Feeds

#### STIX 2.1 (Structured Threat Information Expression)

- JSON-based language for expressing cyber threat intelligence.
- Key object types for RE integration:
  - **Malware**: Represents malware family with name, aliases, capabilities.
  - **Attack Pattern**: Maps to MITRE ATT&CK techniques.
  - **Indicator**: Contains detection patterns (YARA rules, Snort rules,
    file hashes) with valid-time windows.
  - **Observed Data**: Raw observations (IP addresses, domains, file hashes).
  - **Relationship**: Links objects (e.g., malware *uses* attack-pattern).
  - **Note / Opinion** (STIX 2.1 additions): Allow analysts to annotate
    and assess intelligence.
- **STIX 2.1 bundles**: Natural output format for automated RE pipelines
  that produce IOCs, capability mappings, and family classifications.

#### TAXII 2.1 (Trusted Automated Exchange of Intelligence Information)

- Application protocol for exchanging STIX bundles over HTTPS.
- Server-client model: TAXII servers host collections of STIX objects;
  clients poll for updates.
- **ATT&CK TAXII Server**: Official MITRE server providing ATT&CK
  knowledge base as STIX 2.1 objects.
  Repository: [mitre-attack/attack-stix-data](https://github.com/mitre-attack/attack-stix-data)
- Python libraries: `cti-taxii-client`, `cti-python-stix2` for
  programmatic access.

### 7.2 MITRE ATT&CK Mapping from RE Results

#### Automated Mapping Pipeline

```
RE Analysis Results
    |
    v
[capa results] --> ATT&CK technique IDs (capa rules include T-codes)
    |
    v
[Behavioral analysis] --> API sequences mapped to techniques
    |                      (e.g., CreateRemoteThread -> T1055)
    v
[Network IOCs] --> Infrastructure techniques
    |              (e.g., DNS tunneling -> T1071.004)
    v
[STIX Attack Pattern objects] --> Linked to Malware object
    |
    v
[ATT&CK Navigator layer] --> Visual technique coverage map
```

#### Key Mappings (Common RE Findings -> ATT&CK)

| RE Finding | ATT&CK Technique | ID |
|---|---|---|
| Process injection (WriteProcessMemory + CreateRemoteThread) | Process Injection | T1055 |
| API hashing / dynamic resolution | Obfuscated Files or Information | T1027 |
| Registry Run key persistence | Boot or Logon Autostart Execution | T1547.001 |
| Scheduled task creation | Scheduled Task/Job | T1053 |
| Credential file access (browser DBs) | Credentials from Password Stores | T1555 |
| Keylogging (SetWindowsHookEx) | Input Capture: Keylogging | T1056.001 |
| Screen capture (BitBlt/GDI) | Screen Capture | T1113 |
| HTTP C2 communication | Application Layer Protocol: Web | T1071.001 |
| DNS tunneling | Application Layer Protocol: DNS | T1071.004 |
| Packed/encrypted payload | Software Packing | T1027.002 |

#### capa -> ATT&CK

- capa rules include ATT&CK technique and tactic tags.
- capa output in JSON format includes ATT&CK mappings that can be directly
  converted to STIX Attack Pattern objects.
- This is the most practical automated path from "Ghidra analysis" to
  "ATT&CK coverage map."

### 7.3 Automated IOC Extraction

#### IOC Types from RE

| IOC Type | Extraction Method | Tool |
|---|---|---|
| File hashes (MD5/SHA1/SHA256) | Hash the sample | Any; standard |
| Mutex names | String extraction + behavioral | FLOSS, capa, sandbox |
| Registry keys/values | Behavioral analysis | Sandbox, API trace |
| Network indicators (IPs, domains, URLs) | String extraction + PCAP | FLOSS, FakeNet-NG, sandbox |
| C2 config (URLs, keys, bot IDs) | Config extraction | CAPE, custom scripts |
| YARA rules | Automated generation | AutoYara, YARA-Signator |
| Certificates (signing, TLS) | PE parsing / PCAP | Ghidra, Wireshark |
| Email addresses | String extraction | FLOSS, strings |
| Bitcoin/crypto addresses | Regex on strings | Custom scripts |
| Imported/resolved API patterns | Static + dynamic analysis | Ghidra, capa |

#### Automated Extraction Pipeline

1. **Static**: FLOSS extracts obfuscated strings; capa identifies capabilities;
   PE header parsing extracts metadata (imphash, rich header hash, timestamps).
2. **Dynamic**: Sandbox produces API traces, PCAP, memory dumps, dropped files.
3. **Correlation**: Cross-reference static and dynamic IOCs; deduplicate.
4. **Enrichment**: Query VirusTotal, OPSWAT, MISP for known associations.
5. **Export**: Generate STIX 2.1 bundle with all IOCs as Indicator objects
   linked to the Malware object via Relationship objects.

### 7.4 MISP Integration

- **URL**: [misp-project.org](https://www.misp-project.org/)
- MISP (Malware Information Sharing Platform) is the de facto standard for
  threat intelligence sharing in the security community.

#### Integration Points for RE Workflows

| Integration | Method | Purpose |
|---|---|---|
| **IOC submission** | MISP REST API (PyMISP) | Push extracted IOCs to MISP events |
| **STIX import/export** | misp-stix library | Bidirectional STIX 2.1 conversion |
| **YARA rule sharing** | MISP attributes (type: yara) | Share detection signatures |
| **ATT&CK galaxy** | MISP galaxies | Tag events with ATT&CK techniques |
| **Correlation** | MISP correlation engine | Automatic cross-event correlation on shared attributes |
| **Feed consumption** | MISP feeds | Ingest OSINT and commercial feeds |
| **Enrichment** | MISP modules | VirusTotal, Shodan, PassiveTotal lookups |
| **Taxonomies** | MISP taxonomies | Standardized classification (TLP, admiralty) |

#### MISP-STIX Conversion

- **Library**: [MISP/misp-stix](https://github.com/MISP/misp-stix)
- Converts between MISP events and STIX 2.1 bundles.
- STIX 2.1 Note and Opinion objects are supported via the updated
  misp-stix library (2025+).
- Not lossless: some MISP-specific fields may not map cleanly to STIX
  objects and vice versa, but "good enough" for most operational workflows.

#### OpenCTI as Alternative

- OpenCTI (2025) has improved ATT&CK mapping, campaign timeline
  contextualization, and actor profiling.
- STIX 2.1 native; can ingest MISP feeds and export to MISP.
- Better suited for organizations that want a graph-based CTI platform
  rather than MISP's event-centric model.

---

## Comprehensive Tool Comparison

### Unpacking Tools

| Tool | Technique | Packer Support | Automation | Limitations |
|---|---|---|---|---|
| **Unipacker** | Unicorn emulation | UPX, ASPack, PEtite, FSG | Full | No Themida/VMProtect; 32-bit only |
| **Pinicorn** | Intel Pin DBI | Themida, VMProtect, ASProtect | Full | 32-bit PE only; research prototype |
| **PE-sieve** | Memory artifact scanning | Any (post-execution) | Full | Requires running sample |
| **Hollows Hunter** | PE-sieve on all processes | Any (post-execution) | Full | Requires running sample |
| **Qiling** | OS-level emulation | Custom (scriptable) | Semi | Requires custom unpacking script |
| **x64dbg + Scylla** | Manual debugging | Any | Manual | Requires analyst skill |
| **UPX -d** | Native decompressor | UPX only | Full | Fails on modified UPX |

### Anti-Analysis Bypass Tools

| Tool | Mode | Coverage | Supports |
|---|---|---|---|
| **ScyllaHide** | User-mode hooks | Anti-debug (PEB, timing, context, API) | OllyDbg, x64dbg, IDA |
| **TitanHide** | Kernel-mode SSDT | Anti-debug (kernel-level, direct syscalls) | x64dbg, any debugger |
| **WubbabooMark** | Benchmark | Tests bypass effectiveness | Validation tool |
| **al-khaser** | Test suite | Anti-debug, anti-VM, anti-sandbox | Validation tool |

### Sandbox Platforms

| Feature | CAPE | ANY.RUN | Joe Sandbox | Triage |
|---|---|---|---|---|
| **Open Source** | Yes | No | No | No |
| **Interactive** | No | Yes | No | No |
| **Config Extraction** | 300+ families | Limited | Extensive | Growing |
| **Multi-OS** | Windows/Linux | Windows | Win/Mac/Linux/Android/iOS | Win/Linux/Android |
| **Dynamic capa** | Native | No | No | No |
| **AI Features** | No | TI Lookup | Joe Sandbox AI (2025) | No |
| **On-Premise** | Yes | No | Yes | No |
| **Free Tier** | Full (self-host) | Yes (limited) | No | Yes (limited) |

### Behavioral Analysis Tools

| Tool | Type | Platform | Key Strength |
|---|---|---|---|
| **API Monitor** | API hooking | Windows | 13,000+ API definitions, GUI |
| **Frida** | DBI (injection) | Cross-platform | Scriptable, modifiable hooks |
| **ETW** | Kernel tracing | Windows | No injection needed, comprehensive |
| **strace** | ptrace | Linux | Standard, zero setup |
| **drstrace** | DBI (DynamoRIO) | Windows | strace-equivalent for Windows |
| **Process Monitor** | Filter driver | Windows | Real-time, Microsoft-supported |
| **FakeNet-NG** | Network simulation | Windows/Linux | Single-host, all protocols |
| **INetSim** | Network simulation | Linux | Full protocol suite |

---

## EPIC E26 Operationalization: Malware Domain Pack

### Pack Contract (Reproducible + Policy-Safe)

| Contract Element | Requirement | Release Check |
|---|---|---|
| `pack_id` | Immutable semantic version (example: `malware-pack-v1.0.0`) | Pack ID is recorded in manifest and decision packet |
| Dataset provenance | Every sample includes `sha256`, source URL, license/disposition, and acquisition date | Any missing provenance is blocking |
| Deterministic seed | Fixed `EVAL_SEED` and run manifest hash captured in outputs | Re-run on same commit reproduces metrics within tolerance |
| Execution profile | Detonation and dynamic traces run only in isolated sandboxes (no production host execution) | Sandbox profile hash is present in run metadata |
| Egress policy | Default deny egress; explicit allowlist only for controlled TI endpoints | Any non-allowlisted connection is blocking |
| Artifact integrity | Metrics, traces, and receipts are packaged with SHA-256 manifest | Artifact hash mismatch is blocking |

### Baseline-vs-Pack Lift Harness

Run contract (example, deterministic local runner):

```bash
bash eval/run_smoke.sh \
  --real-target-manifest eval/reports/e23/real_target_manifest.json \
  --output eval/output/smoke/e26-malware-pack-metrics.json

python3 eval/scripts/check_regression.py \
  --current eval/output/smoke/e26-malware-pack-metrics.json \
  --baseline eval/reports/e23/real_target_baseline.json \
  --output eval/output/smoke/e26-malware-pack-regression.json
```

Lift scorecard requirements for `malware` slice (pack output must beat stock baseline):

| Metric | Stock Baseline Comparator | Pack Target | Gate |
|---|---|---|---|
| Unpack success rate | Stock headless import+analysis success on packed corpus | `>= +0.15` absolute lift | Block if not met |
| Config extraction recall | Stock capa-only behavioral capability recall | `>= +0.10` absolute lift | Block if not met |
| Anti-analysis pattern recall | Stock API/signature-only anti-analysis detection | `>= +0.12` absolute lift | Block if not met |
| Time-to-first triage label | Stock pipeline median | `<= 0.85x` of baseline latency | Block if regressed |
| False-positive triage labels | Stock baseline false-positive rate | `<= baseline + 0.02` | Block if exceeded |

### Release Decision Artifacts (Limits, Risks, Operator Guidance)

| Artifact | Required Contents | Owner |
|---|---|---|
| `eval/releases/e26/malware/lift-scorecard.md` | Baseline vs pack metrics, confidence bounds, pass/fail decision | Eval/Research |
| `docs/evidence/e26/malware-risk-register.md` | Residual risks, expiration dates, mitigation owner, rollback trigger | Security |
| `docs/evidence/e26/malware-operator-guidance.md` | Allowed environments, denied actions, escalation paths, incident handling | Operations |

Release criteria:
- `GO`: all lift gates pass, no policy-safe violations, and residual risks are accepted with owner/date.
- `HOLD`: any failed lift metric, missing provenance, uncontrolled egress event, or absent operator guidance.

### E26 Domain Pack Deliverables

- Pinned sample set: `docs/evidence/e26/pinned-sample-set.json`
- IOC bundles: `docs/evidence/e26/ioc-bundles.json`
- Evidence-linked behavior maps: `docs/evidence/e26/behavior-map-evidence.json`
- Domain evidence contract: `docs/evidence/e26/README.md`

### E26 Mission Templates

- IOC triage mission: `docs/schemas/examples/mission-dsl/malware-ioc-triage-mission.json`
- Anti-analysis mission: `docs/schemas/examples/mission-dsl/malware-anti-analysis-mission.json`

### E26 Safety Policy Profiles (Executable Enforcement)

- Profile document: `scripts/security/malware_safety_policy_profiles.json`
- Enforcement validator: `scripts/security/validate_malware_safety_profiles.py`
- Abuse-suite runtime check: `scripts/security/run_abuse_scenario_suite.py` (`S6`)

---

## Key Takeaways for Ghidra Integration

### Immediate Opportunities

1. **capa is the bridge**: capa v7+ already integrates with Ghidra
   (capa_explorer.py) and CAPE (dynamic capa). This is the single most
   impactful existing integration for malware triage, providing ATT&CK
   mappings, capability detection, and behavioral analysis in one tool.

2. **Headless triage pipelines are production-ready**: Ghidra's headless
   analyzer + capa + custom post-scripts (string decryption, API hash
   resolution) can process malware at scale. The missing piece is
   standardized output formats (STIX 2.1) and integration with MISP/OpenCTI.

3. **BSim for malware corpus management**: BSim's P-code-based similarity
   search is well-suited for malware family tracking, variant identification,
   and shared code detection. Organizations should build BSim databases
   (PostgreSQL/Elasticsearch) indexed against known malware families from
   Malpedia.

4. **PE-sieve/hollows_hunter -> Ghidra pipeline**: Automated unpacking via
   memory dumping, followed by Ghidra headless import and analysis, is a
   practical end-to-end unpacking workflow that sidesteps the complexity of
   emulation-based OEP detection.

### Medium-Term Integration Targets

5. **FLOSS result import**: Build a Ghidra script that imports FLOSS JSON
   output as comments and labels on the corresponding decryption/construction
   functions. This is a small script with high impact for malware analysts.

6. **Sandbox report annotation**: Import CAPE/ANY.RUN behavioral reports
   into Ghidra as annotations: tag functions that were observed executing
   specific behaviors, add network IOCs as comments at relevant call sites.

7. **STIX 2.1 export from Ghidra**: A Ghidra script that exports analysis
   results (identified capabilities, IOCs, function annotations) as a
   STIX 2.1 bundle, enabling direct submission to MISP/OpenCTI.

8. **Anti-analysis detection in Ghidra**: A script or analyzer that
   identifies known anti-debug/anti-VM patterns in decompiled code (e.g.,
   `IsDebuggerPresent` calls, CPUID checks, timing loops, registry queries
   for VM artifacts) and flags them for the analyst. capa already covers
   many of these via its "anti-analysis" rule namespace.

### Architectural Considerations

9. **Ghidra Server as malware knowledge base**: Combined with BSim databases
   and shared projects, Ghidra Server can serve as a team's institutional
   memory for malware analysis. Each analyzed sample's annotations, type
   definitions, and capability mappings persist and are searchable.

10. **Ghidra + CAPE + MISP stack**: The open-source stack of
    CAPE (detonation + config extraction) -> Ghidra (deep static analysis)
    -> MISP (intelligence sharing) represents a viable alternative to
    commercial platforms for organizations with the engineering capacity
    to integrate and maintain the pipeline.
