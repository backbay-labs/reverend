#!/usr/bin/env python3
"""Validate malware safety policy profiles for fail-closed handling constraints."""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from typing import Any

_ALLOWED_POLICY_MODES = {"offline", "allowlist"}
_DISALLOWED_ALLOWLIST_TOKENS = {"*", "*.*", "0.0.0.0/0", "::/0"}


def _error(message: str) -> str:
    return f"[malware-safety-profile] ERROR: {message}"


def _as_bool(value: Any) -> bool:
    return bool(value) if isinstance(value, bool) else False


def _validate_profile(profile: dict[str, Any], *, index: int) -> list[str]:
    errors: list[str] = []
    profile_id = str(profile.get("profile_id") or f"index-{index}")

    policy_mode = str(profile.get("policy_mode") or "")
    if policy_mode not in _ALLOWED_POLICY_MODES:
        errors.append(_error(f"profile '{profile_id}' has unsupported policy_mode '{policy_mode}'"))

    if not _as_bool(profile.get("sandbox_required")):
        errors.append(_error(f"profile '{profile_id}' must set sandbox_required=true"))

    if not _as_bool(profile.get("detonation_only_in_sandbox")):
        errors.append(_error(f"profile '{profile_id}' must set detonation_only_in_sandbox=true"))

    if not _as_bool(profile.get("default_deny_on_violation")):
        errors.append(_error(f"profile '{profile_id}' must set default_deny_on_violation=true"))

    allowlisted_endpoints = profile.get("allowlisted_endpoints")
    if not isinstance(allowlisted_endpoints, list):
        errors.append(_error(f"profile '{profile_id}' allowlisted_endpoints must be an array"))
        return errors

    normalized = [str(endpoint).strip() for endpoint in allowlisted_endpoints]
    if policy_mode == "allowlist" and not normalized:
        errors.append(_error(f"profile '{profile_id}' in allowlist mode must declare at least one endpoint"))

    for endpoint in normalized:
        if not endpoint:
            errors.append(_error(f"profile '{profile_id}' contains empty allowlisted endpoint"))
            continue
        lower = endpoint.lower()
        if lower in _DISALLOWED_ALLOWLIST_TOKENS:
            errors.append(_error(f"profile '{profile_id}' contains wildcard endpoint '{endpoint}'"))
            continue
        if "*" in endpoint:
            errors.append(_error(f"profile '{profile_id}' contains wildcard endpoint '{endpoint}'"))

    if policy_mode == "offline" and normalized:
        errors.append(_error(f"profile '{profile_id}' in offline mode must not declare allowlisted endpoints"))

    return errors


def validate_profiles(payload: dict[str, Any]) -> list[str]:
    errors: list[str] = []

    if str(payload.get("kind") or "") != "malware_safety_policy_profiles":
        errors.append(_error("kind must equal 'malware_safety_policy_profiles'"))

    try:
        schema_version = int(payload.get("schema_version"))
    except (TypeError, ValueError):
        schema_version = -1
    if schema_version != 1:
        errors.append(_error("schema_version must equal 1"))

    profiles = payload.get("profiles")
    if not isinstance(profiles, list) or not profiles:
        errors.append(_error("profiles must be a non-empty array"))
        return errors

    seen_ids: set[str] = set()
    for idx, raw_profile in enumerate(profiles):
        if not isinstance(raw_profile, dict):
            errors.append(_error(f"profiles[{idx}] must be an object"))
            continue
        profile_id = str(raw_profile.get("profile_id") or "")
        if not profile_id:
            errors.append(_error(f"profiles[{idx}] missing profile_id"))
        elif profile_id in seen_ids:
            errors.append(_error(f"duplicate profile_id '{profile_id}'"))
        else:
            seen_ids.add(profile_id)

        errors.extend(_validate_profile(raw_profile, index=idx))

    return errors


def _load_json(path: Path) -> dict[str, Any]:
    data = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(data, dict):
        raise ValueError("root JSON value must be an object")
    return data


def main() -> int:
    parser = argparse.ArgumentParser(description="Validate malware safety policy profile constraints")
    parser.add_argument(
        "--profiles",
        type=Path,
        default=Path("scripts/security/malware_safety_policy_profiles.json"),
        help="Path to malware safety profile JSON",
    )
    args = parser.parse_args()

    try:
        payload = _load_json(args.profiles)
    except Exception as exc:  # pragma: no cover - CLI-only error path
        print(_error(f"failed to load profile document '{args.profiles}': {exc}"), file=sys.stderr)
        return 1

    errors = validate_profiles(payload)
    if errors:
        for line in errors:
            print(line, file=sys.stderr)
        return 1

    print(f"[malware-safety-profile] OK: {args.profiles}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
